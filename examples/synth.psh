from ./random import *;

let FRAME_WIDTH = 600;
let FRAME_HEIGHT = 400;

let SAMPLE_RATE = 44100;
let SAMPLE_TIME = 1.0 / SAMPLE_RATE;

// Map from note names to frequencies
// For every MIDI note number
let note_freqs = {
    "C-1": 8.18,     // 0
    "C#-1": 8.66,    // 1
    "D-1": 9.18,     // 2
    "D#-1": 9.72,    // 3
    "E-1": 10.30,    // 4
    "F-1": 10.91,    // 5
    "F#-1": 11.56,   // 6
    "G-1": 12.25,    // 7
    "G#-1": 12.98,   // 8
    "A-1": 13.75,    // 9
    "A#-1": 14.57,   // 10
    "B-1": 15.43,    // 11
    "C0": 16.35,     // 12
    "C#0": 17.32,    // 13
    "D0": 18.35,     // 14
    "D#0": 19.45,    // 15
    "E0": 20.60,     // 16
    "F0": 21.83,     // 17
    "F#0": 23.12,    // 18
    "G0": 24.50,     // 19
    "G#0": 25.96,    // 20
    "A0": 27.50,     // 21
    "A#0": 29.14,    // 22
    "B0": 30.87,     // 23
    "C1": 32.70,     // 24
    "C#1": 34.65,    // 25
    "D1": 36.71,     // 26
    "D#1": 38.89,    // 27
    "E1": 41.20,     // 28
    "F1": 43.65,     // 29
    "F#1": 46.25,    // 30
    "G1": 49.00,     // 31
    "G#1": 51.91,    // 32
    "A1": 55.00,     // 33
    "A#1": 58.27,    // 34
    "B1": 61.74,     // 35
    "C2": 65.41,     // 36
    "C#2": 69.30,    // 37
    "D2": 73.42,     // 38
    "D#2": 77.78,    // 39
    "E2": 82.41,     // 40
    "F2": 87.31,     // 41
    "F#2": 92.50,    // 42
    "G2": 98.00,     // 43
    "G#2": 103.83,   // 44
    "A2": 110.00,    // 45
    "A#2": 116.54,   // 46
    "B2": 123.47,    // 47
    "C3": 130.81,    // 48
    "C#3": 138.59,   // 49
    "D3": 146.83,    // 50
    "D#3": 155.56,   // 51
    "E3": 164.81,    // 52
    "F3": 174.61,    // 53
    "F#3": 185.00,   // 54
    "G3": 196.00,    // 55
    "G#3": 207.65,   // 56
    "A3": 220.00,    // 57
    "A#3": 233.08,   // 58
    "B3": 246.94,    // 59
    "C4": 261.63,    // 60
    "C#4": 277.18,   // 61
    "D4": 293.66,    // 62
    "D#4": 311.13,   // 63
    "E4": 329.63,    // 64
    "F4": 349.23,    // 65
    "F#4": 369.99,   // 66
    "G4": 392.00,    // 67
    "G#4": 415.30,   // 68
    "A4": 440.00,    // 69
    "A#4": 466.16,   // 70
    "B4": 493.88,    // 71
    "C5": 523.25,    // 72
    "C#5": 554.37,   // 73
    "D5": 587.33,    // 74
    "D#5": 622.25,   // 75
    "E5": 659.26,    // 76
    "F5": 698.46,    // 77
    "F#5": 739.99,   // 78
    "G5": 783.99,    // 79
    "G#5": 830.61,   // 80
    "A5": 880.00,    // 81
    "A#5": 932.33,   // 82
    "B5": 987.77,    // 83
    "C6": 1046.50,   // 84
    "C#6": 1108.73,  // 85
    "D6": 1174.66,   // 86
    "D#6": 1244.51,  // 87
    "E6": 1318.51,   // 88
    "F6": 1396.91,   // 89
    "F#6": 1479.98,  // 90
    "G6": 1567.98,   // 91
    "G#6": 1661.22,  // 92
    "A6": 1760.00,   // 93
    "A#6": 1864.66,  // 94
    "B6": 1975.53,   // 95
    "C7": 2093.00,   // 96
    "C#7": 2217.46,  // 97
    "D7": 2349.32,   // 98
    "D#7": 2489.02,  // 99
    "E7": 2637.02,   // 100
    "F7": 2793.83,   // 101
    "F#7": 2959.96,  // 102
    "G7": 3135.96,   // 103
    "G#7": 3322.44,  // 104
    "A7": 3520.00,   // 105
    "A#7": 3729.31,  // 106
    "B7": 3951.07,   // 107
    "C8": 4186.01,   // 108
    "C#8": 4434.92,  // 109
    "D8": 4698.63,   // 110
    "D#8": 4978.03,  // 111
    "E8": 5274.04,   // 112
    "F8": 5587.65,   // 113
    "F#8": 5919.91,  // 114
    "G8": 6271.93,   // 115
    "G#8": 6644.88,  // 116
    "A8": 7040.00,   // 117
    "A#8": 7458.62,  // 118
    "B8": 7902.13,   // 119
    "C9": 8372.02,   // 120
    "C#9": 8869.84,  // 121
    "D9": 9397.27,   // 122
    "D#9": 9956.06,  // 123
    "E9": 10548.08,  // 124
    "F9": 11175.30,  // 125
    "F#9": 11839.82, // 126
    "G9": 12543.85   // 127
};

// Sawtooth wave oscillator
class SawOsc
{
    init(self)
    {
        // Current time position
        self.phase = 0.0;
        self.minVal = -1.0;
        self.maxVal = 1.0;
    }

    update(self, freq)
    {
        self.phase = (self.phase + SAMPLE_TIME * freq) % 1.0;
        return self.minVal + self.phase * (self.maxVal - self.minVal);
    }
}

// Sine wave oscillator
class SineOsc
{
    init(self)
    {
        // Current time position
        self.phase = 0;
        self.minVal = -1.0;
        self.maxVal = 1.0;
    }

    update(self, freq)
    {
        self.phase = (self.phase + SAMPLE_TIME * freq) % 1.0;

        let v = (2.0 * 3.141592 * self.phase).sin();
        let normVal = (v + 1) / 2;

        return self.minVal + normVal * (self.maxVal - self.minVal);
    }
}

// Basic IIR, 2-pole, resonant Low Pass Filter (LPF)
class Filter
{
    init(self)
    {
        self.s0 = 0.0;
        self.s1 = 0.0;
    }

    update(self, s, cutoff, resonance)
    {
        //assert (!isNaN(s), 'NaN value fed in TwoPoleFilter');

        // Out of bound values can produce NaNs
        let cut = cutoff.min(1.0);
        let reso = resonance.max(0.0);

        let c = (0.5).pow((1 - cut) / 0.125);
        let r = (0.5).pow((reso + 0.125) / 0.125);
        let mrc = 1 - r * c;

        let v0 = self.s0;
        let v1 = self.s1;

        // Apply the filter to the sample
        self.v0 = (mrc * v0) - (c * v1) + (c * s);
        self.v1 = (mrc * v1) + (c * v0);

        return self.v1;
    }
}

// ADSR envelope generator
class ADSR
{
    init(self, attack_time, decay_time, sustain_level, release_time)
    {
        self.attack_time = attack_time;
        self.decay_time = decay_time;
        self.sustain_level = sustain_level;
        self.release_time = release_time;

        self.state = "idle";
        self.value = 0.0;
        self.time_in_state = 0.0;
    }

    trigger(self)
    {
        self.state = "attack";
        self.time_in_state = 0.0;
    }

    release(self)
    {
        self.state = "release";
        self.time_in_state = 0.0;
    }

    update(self)
    {
        self.time_in_state = self.time_in_state + SAMPLE_TIME;

        if (self.state == "attack")
        {
            if (self.time_in_state >= self.attack_time)
            {
                self.state = "decay";
                self.time_in_state = 0.0;
                self.value = 1.0;
            }
            else
            {
                self.value = self.time_in_state / self.attack_time;
            }
        }
        else if (self.state == "decay")
        {
            if (self.time_in_state >= self.decay_time)
            {
                self.state = "sustain";
                self.time_in_state = 0.0;
                self.value = self.sustain_level;
            }
            else
            {
                let decay_amount = 1.0 - self.sustain_level;
                self.value = 1.0 - (self.time_in_state / self.decay_time) * decay_amount;
            }
        }
        else if (self.state == "sustain")
        {
            // In sustain, the value remains constant
            self.value = self.sustain_level;
        }
        else if (self.state == "release")
        {
            if (self.time_in_state >= self.release_time)
            {
                self.state = "idle";
                self.time_in_state = 0.0;
                self.value = 0.0;
            }
            else
            {
                // The value at the start of the release is the sustain level
                let release_start_value = self.sustain_level;
                self.value = release_start_value - (self.time_in_state / self.release_time) * release_start_value;
            }
        }
        else // idle
        {
            self.value = 0.0;
        }

        return self.value.clip(0.0, 1.0);
    }
}

class Synth
{
    init(self)
    {
        self.lfo0 = SineOsc();
        self.osc0 = SawOsc();
        self.env0 = ADSR(0.01, 0.1, 0.5, 0.4);
        self.filter = Filter();

        self.freq = 0;
    }

    note_on(self, freq)
    {
        self.freq = freq;
        self.env.trigger();
    }

    note_off(self)
    {
        self.env0.release();
    }

    gen_samples(self, num_samples, buffer)
    {
        //let l0 = lfo0.update(300);
        //let l1 = lfo1.update(300);

        let osc0 = self.osc0.update(self.freq);

        let env0 = self.env0.update();

        return osc0 * env0;
    }
}

// Actor responsible for generating sound
fun audio_actor()
{
    let audio_dev = $audio_open_output(SAMPLE_RATE, 1);

    let var synth = Synth();

    let buffer = ByteArray.with_size(1024 * 4);

    loop {
        let msg = $actor_recv();

        // The audio driver needs more samples
        if (msg instanceof AudioNeeded) {
            let t0 = $time_current_ms();

            synth.gen_samples(msg.num_samples, buffer);
            $audio_write_samples(audio_dev, buffer);

            let t1 = $time_current_ms();
            let dt = t1 - t0;
            let avail_ms = (1000 * msg.num_samples / SAMPLE_RATE).floor();
            $println(dt.to_s() + 'ms (/' + avail_ms.to_s() + ')');
        }
    }
}

let window = $window_create(FRAME_WIDTH, FRAME_HEIGHT, "Random Synth Generator", 0);
let frame_buffer = ByteArray.with_size(FRAME_WIDTH * FRAME_HEIGHT * 4);
$window_draw_frame(window, frame_buffer);

let synth_actor = $actor_spawn(audio_actor);

// Main event loop
loop {
    let msg = $actor_recv();

    if (!(msg instanceof UIEvent))
        continue;

    if (msg.kind == 'CLOSE_WINDOW' || msg.key == 'ESCAPE') {
        break;
    }

    //draw_visualization(frame_buffer);
    $window_draw_frame(window, frame_buffer);
}
