from ./random import *;

let FRAME_WIDTH = 600;
let FRAME_HEIGHT = 400;

let SAMPLE_RATE = 44100;
let SAMPLE_TIME = 1.0 / SAMPLE_RATE;

// Map from note names to frequencies
// For every MIDI note number
let note_freqs = {
    "C-1": 8.18,     // 0
    "C#-1": 8.66,    // 1
    "D-1": 9.18,     // 2
    "D#-1": 9.72,    // 3
    "E-1": 10.30,    // 4
    "F-1": 10.91,    // 5
    "F#-1": 11.56,   // 6
    "G-1": 12.25,    // 7
    "G#-1": 12.98,   // 8
    "A-1": 13.75,    // 9
    "A#-1": 14.57,   // 10
    "B-1": 15.43,    // 11
    "C0": 16.35,     // 12
    "C#0": 17.32,    // 13
    "D0": 18.35,     // 14
    "D#0": 19.45,    // 15
    "E0": 20.60,     // 16
    "F0": 21.83,     // 17
    "F#0": 23.12,    // 18
    "G0": 24.50,     // 19
    "G#0": 25.96,    // 20
    "A0": 27.50,     // 21
    "A#0": 29.14,    // 22
    "B0": 30.87,     // 23
    "C1": 32.70,     // 24
    "C#1": 34.65,    // 25
    "D1": 36.71,     // 26
    "D#1": 38.89,    // 27
    "E1": 41.20,     // 28
    "F1": 43.65,     // 29
    "F#1": 46.25,    // 30
    "G1": 49.00,     // 31
    "G#1": 51.91,    // 32
    "A1": 55.00,     // 33
    "A#1": 58.27,    // 34
    "B1": 61.74,     // 35
    "C2": 65.41,     // 36
    "C#2": 69.30,    // 37
    "D2": 73.42,     // 38
    "D#2": 77.78,    // 39
    "E2": 82.41,     // 40
    "F2": 87.31,     // 41
    "F#2": 92.50,    // 42
    "G2": 98.00,     // 43
    "G#2": 103.83,   // 44
    "A2": 110.00,    // 45
    "A#2": 116.54,   // 46
    "B2": 123.47,    // 47
    "C3": 130.81,    // 48
    "C#3": 138.59,   // 49
    "D3": 146.83,    // 50
    "D#3": 155.56,   // 51
    "E3": 164.81,    // 52
    "F3": 174.61,    // 53
    "F#3": 185.00,   // 54
    "G3": 196.00,    // 55
    "G#3": 207.65,   // 56
    "A3": 220.00,    // 57
    "A#3": 233.08,   // 58
    "B3": 246.94,    // 59
    "C4": 261.63,    // 60
    "C#4": 277.18,   // 61
    "D4": 293.66,    // 62
    "D#4": 311.13,   // 63
    "E4": 329.63,    // 64
    "F4": 349.23,    // 65
    "F#4": 369.99,   // 66
    "G4": 392.00,    // 67
    "G#4": 415.30,   // 68
    "A4": 440.00,    // 69
    "A#4": 466.16,   // 70
    "B4": 493.88,    // 71
    "C5": 523.25,    // 72
    "C#5": 554.37,   // 73
    "D5": 587.33,    // 74
    "D#5": 622.25,   // 75
    "E5": 659.26,    // 76
    "F5": 698.46,    // 77
    "F#5": 739.99,   // 78
    "G5": 783.99,    // 79
    "G#5": 830.61,   // 80
    "A5": 880.00,    // 81
    "A#5": 932.33,   // 82
    "B5": 987.77,    // 83
    "C6": 1046.50,   // 84
    "C#6": 1108.73,  // 85
    "D6": 1174.66,   // 86
    "D#6": 1244.51,  // 87
    "E6": 1318.51,   // 88
    "F6": 1396.91,   // 89
    "F#6": 1479.98,  // 90
    "G6": 1567.98,   // 91
    "G#6": 1661.22,  // 92
    "A6": 1760.00,   // 93
    "A#6": 1864.66,  // 94
    "B6": 1975.53,   // 95
    "C7": 2093.00,   // 96
    "C#7": 2217.46,  // 97
    "D7": 2349.32,   // 98
    "D#7": 2489.02,  // 99
    "E7": 2637.02,   // 100
    "F7": 2793.83,   // 101
    "F#7": 2959.96,  // 102
    "G7": 3135.96,   // 103
    "G#7": 3322.44,  // 104
    "A7": 3520.00,   // 105
    "A#7": 3729.31,  // 106
    "B7": 3951.07,   // 107
    "C8": 4186.01,   // 108
    "C#8": 4434.92,  // 109
    "D8": 4698.63,   // 110
    "D#8": 4978.03,  // 111
    "E8": 5274.04,   // 112
    "F8": 5587.65,   // 113
    "F#8": 5919.91,  // 114
    "G8": 6271.93,   // 115
    "G#8": 6644.88,  // 116
    "A8": 7040.00,   // 117
    "A#8": 7458.62,  // 118
    "B8": 7902.13,   // 119
    "C9": 8372.02,   // 120
    "C#9": 8869.84,  // 121
    "D9": 9397.27,   // 122
    "D#9": 9956.06,  // 123
    "E9": 10548.08,  // 124
    "F9": 11175.30,  // 125
    "F#9": 11839.82, // 126
    "G9": 12543.85   // 127
};

// Sawtooth wave oscillator
class SawOsc
{
    init(self)
    {
        // Current time position
        self.phase = 0.0;
        self.minVal = -1.0;
        self.maxVal = 1.0;
    }

    update(self, freq)
    {
        self.phase = (self.phase + SAMPLE_TIME * freq) % 1.0;
        return self.minVal + self.phase * (self.maxVal - self.minVal);
    }
}

// Sine wave oscillator
class SineOsc
{
    init(self)
    {
        // Current time position
        self.phase = 0;
        self.minVal = -1.0;
        self.maxVal = 1.0;
    }

    update(self, freq)
    {
        self.phase = (self.phase + SAMPLE_TIME * freq) % 1.0;

        let v = (2.0 * 3.141592 * self.phase).sin();
        let normVal = (v + 1) / 2;

        return self.minVal + normVal * (self.maxVal - self.minVal);
    }
}

// ADSR envelope generator
class ADSR
{
    init(self, attack_time, decay_time, sustain_level, release_time)
    {
        self.attack_time = attack_time;
        self.decay_time = decay_time;
        self.sustain_level = sustain_level;
        self.release_time = release_time;

        self.state = "idle";
        self.value = 0.0;
        self.time_in_state = 0.0;
    }

    trigger(self)
    {
        self.state = "attack";
        self.time_in_state = 0.0;
    }

    release(self)
    {
        self.state = "release";
        self.time_in_state = 0.0;
    }

    update(self)
    {
        self.time_in_state = self.time_in_state + SAMPLE_TIME;

        if (self.state == "attack")
        {
            if (self.time_in_state >= self.attack_time)
            {
                self.state = "decay";
                self.time_in_state = 0.0;
                self.value = 1.0;
            }
            else
            {
                self.value = self.time_in_state / self.attack_time;
            }
        }
        else if (self.state == "decay")
        {
            if (self.time_in_state >= self.decay_time)
            {
                self.state = "sustain";
                self.time_in_state = 0.0;
                self.value = self.sustain_level;
            }
            else
            {
                let decay_amount = 1.0 - self.sustain_level;
                self.value = 1.0 - (self.time_in_state / self.decay_time) * decay_amount;
            }
        }
        else if (self.state == "sustain")
        {
            // In sustain, the value remains constant
            self.value = self.sustain_level;
        }
        else if (self.state == "release")
        {
            if (self.time_in_state >= self.release_time)
            {
                self.state = "idle";
                self.time_in_state = 0.0;
                self.value = 0.0;
            }
            else
            {
                // The value at the start of the release is the sustain level
                let release_start_value = self.sustain_level;
                self.value = release_start_value - (self.time_in_state / self.release_time) * release_start_value;
            }
        }
        else // idle
        {
            self.value = 0.0;
        }

        return self.value.clip(0.0, 1.0);
    }
}

// Basic IIR, 2-pole, resonant Low Pass Filter (LPF)
class Filter
{
    init(self)
    {
        self.s0 = 0.0;
        self.s1 = 0.0;
    }

    update(self, s, cutoff, resonance)
    {
        //assert (!isNaN(s), 'NaN value fed in TwoPoleFilter');

        // Out of bound values can produce NaNs
        let cut = cutoff.min(1.0);
        let reso = resonance.max(0.0);

        let c = (0.5).pow((1 - cut) / 0.125);
        let r = (0.5).pow((reso + 0.125) / 0.125);
        let mrc = 1 - r * c;

        let var v0 = self.s0;
        let var v1 = self.s1;

        // Apply the filter to the sample
        v0 = (mrc * v0) - (c * v1) + (c * s);
        v1 = (mrc * v1) + (c * v0);

        self.s0 = v0;
        self.s1 = v1;

        return v1;
    }
}

class Synth
{
    init(self)
    {
        self.lfo0 = SineOsc();
        self.lfo0_freq = rand_float(0.20, 0.60);
        self.lfo0.minVal = 0.90;
        self.lfo0.maxVal = 1.10;

        self.osc0 = SawOsc();
        self.osc1 = SawOsc();
        self.osc2 = SineOsc();
        self.detune1 = rand_float(0.97, 1.03);
        self.detune2 = 0.5 * rand_float(0.97, 1.03);

        if (rand_float(0.0, 1.0) < 0.25) {
            self.detune1 = self.detune1 * 2.0;
        } else if (rand_float(0.0, 1.0) < 0.25) {
            self.detune1 = self.detune1 * 0.5;
        }

        self.env0 = ADSR(
            rand_float(0.001, 0.02),
            rand_float(0.02, 0.40),
            rand_float(0.05, 0.60),
            rand_float(0.05, 0.60),
        );

        self.env1 = ADSR(
            rand_float(0.001, 0.02),
            rand_float(0.02, 0.40),
            rand_float(0.05, 0.60),
            rand_float(0.05, 0.60),
        );

        self.filter = Filter();
        self.cutoff = rand_float(0.60, 1.00);
        self.reso = rand_float(0.00, 0.30);

        self.drive = 1.0;
        if (rand_float(0.0, 1.0) < 0.25) {
            self.drive = rand_float(1.1, 6.0);
        }

        // Frequency of current note
        self.freq = 0;
    }

    note_on(self, freq)
    {
        self.freq = freq;
        self.env0.trigger();
    }

    note_off(self)
    {
        self.env0.release();
    }

    gen_sample(self)
    {
        let lfo0 = self.lfo0.update(self.lfo0_freq);

        let osc0 = self.osc0.update(self.freq);
        let osc1 = self.osc1.update(self.freq) * self.detune1;
        //let osc2 = self.osc2.update(self.freq) * self.detune2;
        //let s = osc0 + osc1 + osc2;
        let s = osc0 + osc1;

        let env0 = self.env0.update();
        //let env1 = self.env0.update();

        let filtered_s = self.filter.update(
            s * env0,
            self.cutoff * env0 * lfo0,
            self.reso,
        );

        // Apply distortion
        let distorted_s = (filtered_s * self.drive).clip(-1.0, 1.0);

        return distorted_s;
    }
}

// Takes a sequence of notes and returns a list of events
// samples_per_step: number of audio samples per sequencer step
fun notes_to_events(sequence, samples_per_step)
{
    let events = [];

    for (let var i = 0; i < sequence.len; ++i) {
        let note_name = sequence[i];
        let duration_steps = 1;
        let duration_samples = duration_steps * samples_per_step;

        if (note_name != nil) {
            let freq = note_freqs[note_name];
            events.push({
                type: "note_on",
                sample_idx: i * samples_per_step,
                freq: freq,
            });

            // Add a note_off event. Let's make the note last for nearly the full duration.
            // A short silence between notes can make them more distinct.
            let note_duration_samples = (duration_samples * 0.95).floor();

            events.push({
                type: "note_off",
                sample_idx: i * samples_per_step + note_duration_samples,
                freq: freq, // freq might be useful to turn off a specific note if we have polyphony
            });
        }
    }

    // TODO: sort events by sample_idx if we want to support polyphony correctly

    return events;
}

// Actor responsible for generating sound
fun audio_actor()
{
    let audio_dev = $audio_open_output(SAMPLE_RATE, 1);
    let buffer = ByteArray.with_size(1024 * 4);

    let var synth = Synth();

    let tempo_bpm = 120;
    let beats_per_bar = 4;
    let steps_per_bar = 16;
    let bars_per_min = tempo_bpm / beats_per_bar;
    let bars_per_sec = bars_per_min / 60;
    let steps_per_sec = steps_per_bar * bars_per_sec;
    let samples_per_step = (SAMPLE_RATE / steps_per_sec).floor();
    $println('steps per sec: ' + steps_per_sec.to_s());
    $println('samples per step: ' + samples_per_step.to_s());

    let sequence = [
        'C2', 'D#2', 'G2', 'C2', 'D#2', 'G2', 'C2', 'D#2',
        'G2', 'C2', 'D#2', 'G2', 'C2', 'D#2', 'G2', 'C2',
    ];

    let events = notes_to_events(sequence, samples_per_step);

    // Index of the next event to be triggered
    let var next_event_idx = 0;

    // Index of the next sample to be generated
    let var sample_idx = 0;

    loop {
        let msg = $actor_recv();

        if (msg == 'REPLAY') {
            next_event_idx = 0;
            sample_idx = 0;
            continue;
        }

        if (msg == 'NEW_SYNTH') {
            synth = Synth();
            next_event_idx = 0;
            sample_idx = 0;
            continue;
        }

        // The audio driver needs more samples
        if (msg instanceof AudioNeeded) {
            let t0 = $time_current_ms();

            let num_samples_to_gen = msg.num_samples;
            let var buffer_idx = 0;

            while (buffer_idx < num_samples_to_gen) {
                // If no more events, just fill the buffer
                if (next_event_idx >= events.len) {
                    while (buffer_idx < num_samples_to_gen) {
                        buffer.set_f32(buffer_idx, synth.gen_sample());
                        ++buffer_idx;
                    }
                    break;
                }

                let next_event = events[next_event_idx];
                let next_event_abs_pos = next_event.sample_idx;

                // Position of the next event, relative to the start of the audio driver buffer
                let next_event_buf_pos = next_event_abs_pos - sample_idx;

                // Number of samples to render until the next event
                let samples_to_render = (next_event_buf_pos - buffer_idx).max(0).min(num_samples_to_gen - buffer_idx);

                // Render audio until the next event
                for (let var i = 0; i < samples_to_render; ++i) {
                    buffer.set_f32(buffer_idx, synth.gen_sample());
                    ++buffer_idx;
                }

                // If we've reached an event that is within this buffer, process it
                if (buffer_idx >= next_event_buf_pos) {
                    while (next_event_idx < events.len && events[next_event_idx].sample_idx == next_event_abs_pos) {
                        let event = events[next_event_idx];
                        if (event.type == "note_on") {
                            synth.note_on(event.freq);
                        } else if (event.type == "note_off") {
                            synth.note_off();
                        }
                        ++next_event_idx;
                    }
                }
            }

            $audio_write_samples(audio_dev, buffer);

            let t1 = $time_current_ms();
            let dt = t1 - t0;
            let avail_ms = (1000 * msg.num_samples / SAMPLE_RATE).floor();
            $println(dt.to_s() + 'ms (/' + avail_ms.to_s() + ')');

            sample_idx = sample_idx + msg.num_samples;
        }
    }
}

let window = $window_create(FRAME_WIDTH, FRAME_HEIGHT, "Random Synth Generator", 0);
let frame_buffer = ByteArray.with_size(FRAME_WIDTH * FRAME_HEIGHT * 4);
$window_draw_frame(window, frame_buffer);

let synth_actor = $actor_spawn(audio_actor);

// Main event loop
loop {
    let msg = $actor_recv();

    if (!(msg instanceof UIEvent))
        continue;

    if (msg.kind == 'CLOSE_WINDOW') {
        break;
    }

    if (msg.kind == 'KEY_DOWN') {
        if (msg.key == 'ESCAPE') {
            break;
        }

        if (msg.key == 'LEFT') {
            $actor_send(synth_actor, 'REPLAY');
        }

        if (msg.key == 'RIGHT') {
            $actor_send(synth_actor, 'NEW_SYNTH');
        }
    }

    //draw_visualization(frame_buffer);
    $window_draw_frame(window, frame_buffer);
}
