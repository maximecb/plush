let COLOR_BLACK     = 0xFF_00_00_00;
let COLOR_WHITE     = 0xFF_FF_FF_FF;
let COLOR_GREY      = 0xFF_80_80_80;
let COLOR_RED       = 0xFF_FF_00_00;
let COLOR_GREEN     = 0xFF_00_FF_00;
let COLOR_BLUE      = 0xFF_00_00_FF;
let COLOR_ORANGE    = 0xFF_FF_A5_00;
let COLOR_YELLOW    = 0xFF_FF_FF_00;
let COLOR_MAGENTA   = 0xFF_FF_00_FF;
let COLOR_PURPLE    = 0xFF_D6_00_FF;
let COLOR_TURQUOISE = 0xFF_40_E0_D0;
let COLOR_C64_BLUE = rgb(9, 64, 221);

fun rgba(r, g, b, a) {
    return (a << 24) | (r << 16) | (g << 8) | b;
}

fun rgb(r, g, b) {
    return (0xFF << 24) | (r << 16) | (g << 8) | b;
}

fun color_a(p) { return (p >> 24) & 0xFF; }
fun color_r(p) { return (p >> 16) & 0xFF; }
fun color_g(p) { return (p >>  8) & 0xFF; }
fun color_b(p) { return (p >>  0) & 0xFF; }

class Image
{
    init(self, width, height)
    {
        assert(width instanceof Int64);
        assert(height instanceof Int64);

        self.width = width;
        self.height = height;
        self.bytes = ByteArray.with_size(4 * width * height);
    }

    clear(self, color)
    {
        self.bytes.fill_u32(0, self.width * self.height, color);
    }

    // The color is specified as an u32 value in RGBA32 format
    get_pixel(self, x, y)
    {
        let idx = y * self.width + x;
        return(self.bytes.get_u32(idx));
    }

    set_pixel(self, x, y, color)
    {
        let idx = y * self.width + x;
        self.bytes.set_u32(idx, color);
    }

    // Copy a source image into this image at a given position
    blit(self, src_img, dst_x, dst_y)
    {
        self.bytes.blit_bgra32(
            self.width,
            self.height,
            src_img.bytes,
            src_img.width,
            src_img.height,
            dst_x,
            dst_y
        );
    }

    // Bresenham's algorithm
    draw_line(self, x0, y0, x1, y1, color) {
        let sx = (x0 < x1 ? 1 : -1);
        let sy = (y0 < y1 ? 1 : -1);
        let dx = (x1 - x0).abs();
        let dy = (y1 - y0).abs();

        let var err = dx - dy;
        let var x = x0;
        let var y = y0;

        loop {
            self.set_pixel(x, y, color);
            if (x == x1 && y == y1) {
                return;
            }

            let e2 = 2 * err;
            if (e2 > -dy) {
                err = err - dy;
                x = x + sx;
            }

            if (e2 < dx) {
                err = err + dx;
                y = y + sy;
            }
        }
    }

    // Draw a filled rectangle
    fill_rect(self, x, y, w, h, color)
    {
        let var rx = x;
        let var ry = y;
        let var rw = w;
        let var rh = h;

        // Clipping
        if (rx < 0) { rw = rw + rx; rx = 0; }
        if (ry < 0) { rh = rh + ry; ry = 0; }
        if (rx + rw > self.width) { rw = self.width - rx; }
        if (ry + rh > self.height) { rh = self.height - ry; }

        if (rw <= 0 || rh <= 0) { return; }

        for (let var j = 0; j < rh; ++j) {
            let idx = (ry + j) * self.width + rx;
            self.bytes.fill_u32(idx, rw, color);
        }
    }

    // Draw a filled circle
    fill_circle(self, x0, y0, r, color)
    {
        let var x = 0;
        let var y = r;
        let var d = 3 - 2 * r;

        while (y >= x) {
            self.fill_rect(x0 - y, y0 + x, 2 * y + 1, 1, color);
            self.fill_rect(x0 - y, y0 - x, 2 * y + 1, 1, color);
            self.fill_rect(x0 - x, y0 + y, 2 * x + 1, 1, color);
            self.fill_rect(x0 - x, y0 - y, 2 * x + 1, 1, color);

            x = x + 1;
            if (d > 0) {
                y = y - 1;
                d = d + 4 * (x - y) + 10;
            } else {
                d = d + 4 * x + 6;
            }
        }
    }
}
