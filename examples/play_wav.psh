// Represents a parsed WAV file
class WavFile
{
    init(self, num_channels, sample_rate, bits_per_sample, samples)
    {
        self.num_channels = num_channels;
        self.sample_rate = sample_rate;
        self.bits_per_sample = bits_per_sample;
        self.samples = samples;
    }

    // Load a WAV file from the given path
    load(file_path)
    {
        let wav_data = $read_file(file_path);
        if (wav_data == nil) {
            $println("Error: could not read wav file");
            return nil;
        }

        // Offset 0 should be the string RIFF
        if (wav_data.load_u32(0) != 0x46464952) {
            $println("Error: invalid ChunkID for file, not a wave file");
            return nil;
        }

        // Offset 8 should be the string WAVE
        if (wav_data.load_u32(8) != 0x45564157) {
            $println("Error: invalid format, not a wave file");
            return nil;
        }

        if (wav_data.load_u16(20) != 1) {
            $println("Error: only PCM audio format is supported");
            return nil;
        }

        // Parse WAV header
        // Ref: http://soundfile.sapp.org/doc/WaveFormat/
        let num_channels = wav_data.load_u16(22);
        let sample_rate = wav_data.load_u32(24);
        let bits_per_sample = wav_data.load_u16(34);

        if (bits_per_sample != 16) {
            $println("Error: unsupported bits per sample. Only 16-bit WAV files are supported.");
            return nil;
        }

        let var chunk_offset = 36;
        let var chunk_size = nil;

        loop {
            let chunk_id = wav_data.load_u32(chunk_offset);
            chunk_size = wav_data.load_u32(chunk_offset + 4);

            // If we found the data chunk, with ChunkId "data"
            if (chunk_id == 0x61746164) {
                break;
            }

            // Move to the next chunk
            chunk_offset += 8 + chunk_size;
        }

        // For now, assume PCM format and that the data chunk starts at offset 44
        // A proper implementation would search for the "data" chunk
        let data_offset = chunk_offset + 8;

        // Convert 16-bit signed PCM to 32-bit float
        let num_samples = chunk_size _/ (bits_per_sample _/ 8);
        let float_samples = ByteArray.with_size(num_samples * 4);

        for (let var i = 0; i < num_samples; ++i) {
            let sample_offset = data_offset + 2 * i;
            let pcm_sample_u16 = wav_data.load_u16(sample_offset);

            // Convert u16 to i16
            let var pcm_sample_i16 = 0;
            if (pcm_sample_u16 > 32767) {
                pcm_sample_i16 = pcm_sample_u16 - 65536;
            } else {
                pcm_sample_i16 = pcm_sample_u16;
            }

            let float_sample = pcm_sample_i16.to_f() / 32768.0;
            float_samples.set_f32(i, float_sample);
        }

        return WavFile(num_channels, sample_rate, bits_per_sample, float_samples);
    }
}

fun main()
{
    let file_path = $cmd_get_arg_or(1, "examples/sample_nono.wav");

    let wav_file = WavFile.load(file_path);
    if (wav_file == nil) {
        return;
    }

    // Open audio device
    let dev = $audio_open_output(wav_file.sample_rate, wav_file.num_channels);
    if (dev == nil) {
        $println("Error: could not open audio device");
        return;
    }

    $println("Playing audio...");
    $audio_write_samples(dev, wav_file.samples);

    // Wait for the audio to finish playing.
    // A simple approximation: duration = num_samples / sample_rate
    let num_samples = wav_file.samples.len / 4; // 4 bytes per float
    let duration_ms = (num_samples.to_f() / wav_file.sample_rate.to_f() * 1000.0).floor();
    $actor_sleep(duration_ms + 100);
    $println("Playback finished.");
}

main();
