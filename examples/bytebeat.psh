// Partial ByteBeat imp: http://viznut.fi/texts-en/bytebeat_deep_analysis.html
//
// at the moment, literals must be decimal
//
// thus far, only the following operators are supported; precedences taken
// from https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Expression_evaluation_order

let ops = ["*","&","|",">>","<<", "^", "-", "+", "/", "%"];
let prc = [5, 11, 13, 7, 7, 12, 6, 6, 5, 5];

// cargo run examples/bytebeat.psh ["bytebeat expr"] [seconds]

//------------------------------------------------------------------------------
// AST

class Xpr {
    init(self, op, l, r) {
        self.op = op;
        self.l = l;
        self.r = r;
    }
    eval(self, t) {
        if (self.op == "*") {
            return self.l.eval(t) * self.r.eval(t);
        } else if (self.op == "&") {
            return self.l.eval(t) & self.r.eval(t);
        } else if (self.op == "|") {
            return self.l.eval(t) | self.r.eval(t);
        } else if (self.op == ">>") {
            return self.l.eval(t) >> self.r.eval(t);
        } else if (self.op == "<<") {
            return self.l.eval(t) << self.r.eval(t);
        } else if (self.op == "^") {
            return self.l.eval(t) ^ self.r.eval(t);
        } else if (self.op == "+") {
            return self.l.eval(t) + self.r.eval(t);
        } else if (self.op == "-") {
            return self.l.eval(t) - self.r.eval(t);
        } else if (self.op == "/") {
            return self.l.eval(t) _/ self.r.eval(t);
        } else if (self.op == "%") {
            return self.l.eval(t) % self.r.eval(t);
        }
        return 0;
    }
    to_s(self) {
        return "(" + self.l.to_s() + self.op + self.r.to_s() + ")";
    }
}

class Var {
    init(self) {
    }
    eval(self, t) {
        return t;
    }
    to_s(self) {
        return "t";
    }
}

class Lit {
    init(self, v) {
        self.v = v;
    }
    eval(self, t) {
        return self.v;
    }
    to_s(self) {
        return self.v.to_s();
    }
}

//------------------------------------------------------------------------------
// Parsing (quick and dirty)

fun toktype(c) {
    if (48 <= c && c <= 57) { return 0; }
    else if (97 <= c && c <= 122) { return 1; }
    else if (65 <= c && c <= 90) { return 1; }
    else if (40 <= c && c <= 41) { return 2; }
    else { return 3; }
}

class ParseCtx {
    init(self, s) {
        self.s = s;
        self.i = 0;
        self.tok = "";
    }
    token(self) {
        return self.tok;
    }
    lex(self) {
        if (self.i == self.s.len) {
            self.tok = "$";
            return self;
        }
        self.tok = "";
        let t = toktype(self.s.byte_at(self.i));
        loop {
            if (self.i == self.s.len ||
                self.s.byte_at(self.i) == 32) {
                loop {
                    if(self.i == self.s.len ||
                       self.s.byte_at(self.i) != 32) {
                        break;
                    }
                    self.i = self.i + 1;
                }
                return self;
            }
            let b = self.s.byte_at(self.i);
            if (t == toktype(b)) {
                self.tok = self.tok + String.from_codepoint(b);
                self.i = self.i + 1;
            } else {
                return self;
            }
            if (t == 2) { return self; } // parens are always single
        }
    }
}

fun getprc(o) {
    for(let var i = 0; i < ops.len; ++i) {
        if(ops[i] == o) {
            return prc[i];
        }
    }
    return 100;
}

fun prim(pc) {
    let tok = pc.token();
    if (tok == "t") {
        return Var();
    } else if (tok == "(") {
        let v = texpr(pc);
        pc.token() == ")"; // TODO: verify!
        return v;
    } else {
        return Lit(tok.parse_int(10));
    }
}

fun expr(pc, n) {
    let var a = prim(pc);
    pc.lex();
    loop {
        let tok = pc.token();
        let p = getprc(tok);
        if (p < n) {
            a = Xpr(tok, a, expr(pc.lex(), p));
        } else {
            return a;
        }
    }
}

fun texpr(pc) {
    return expr(pc.lex(), 100);
}

// let bb2 = texpr(ParseCtx("(t*5&t>>7)|(t*3&t>>10)"));
// let sample_val = ((t<<1)^((t<<1)+(t>>7)&t>>12))|t>>(4-(1^7&(t>>19)))|t>>7;

//------------------------------------------------------------------------------
// Playback

fun main() {
    let SAMPLE_RATE = 8000;
    let dev = $audio_open_output(SAMPLE_RATE, 1);

    let s = $cmd_get_arg_or(1, "t*(t>>9|t>>13)&16");
    let d = $cmd_get_arg_or(2, "x").parse_int(10);

    let bb = texpr(ParseCtx(s));
    let end_time = $time_current_ms() + (d==nil ? 5 : d)*1000;

    let var t = 0;

    fun gen_samples(bb, num_samples) {
        let samples = ByteArray.with_size(num_samples * 4);

        for (let var i = 0; i < num_samples; ++i) {
            samples.set_f32(i, (bb.eval(t)%256)/127 - 1.0);
            t = (t+1) % 8000;
        }

        return samples;
    }

    $println(bb.to_s());

    loop {
        let msg = $actor_recv();

        if (msg instanceof AudioNeeded) {
            $audio_write_samples(dev, gen_samples(bb, msg.num_samples));
        }
        if ($time_current_ms() > end_time) {
            break;
        }
    }
}

main();
