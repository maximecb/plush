// Constants
let SAMPLE_RATE = 44100;
let NUM_CHANNELS = 1;
let WINDOW_WIDTH = 400;
let WINDOW_HEIGHT = 300;
let FFT_SIZE = 512; // Must be a power of 2
let NUM_MEL_BINS = 32;
let PI = 3.141592653589793;

let MIN_FREQ = 300.0;
let MAX_FREQ = 3500.0;

// Helper function to convert RGB values to a 32-bit color
fun rgb32(r, g, b) {
    // The alpha channel is set to 0xFF (fully opaque)
    return 0xFF000000 | (r << 16) | (g << 8) | b;
}

// Function to perform in-place iterative FFT (Cooley-Tukey)
fun fft(real_parts, imag_parts, inverse) {
    let n = real_parts.len _/ 4; // Number of complex samples (each float32 is 4 bytes)
    if (n == 0) {
        return;
    }

    // Bit-reversal permutation
    let var i = 0;
    let var j = 0;
    while (i < n) {
        if (j > i) {
            // Swap real parts
            let temp_re = real_parts.read_f32(i);
            real_parts.write_f32(i, real_parts.read_f32(j));
            real_parts.write_f32(j, temp_re);

            // Swap imaginary parts
            let temp_im = imag_parts.read_f32(i);
            imag_parts.write_f32(i, imag_parts.read_f32(j));
            imag_parts.write_f32(j, temp_im);
        }
        let var m = n _/ 2;
        while (m >= 1 && j >= m) {
            j = j - m;
            m = m _/ 2;
        }
        j = j + m;
        i = i + 1;
    }

    // Cooley-Tukey butterfly operations
    let var len = 2;
    while (len <= n) {
        let var ang = 2.0 * PI / len;
        if (inverse) {
            ang = -ang;
        }
        let wlen_re = ang.cos();
        let wlen_im = ang.sin();

        let var i = 0;
        while (i < n) {
            let var w_re = 1.0;
            let var w_im = 0.0;
            let var j = 0;
            while (j < len _/ 2) {
                let u_re = real_parts.read_f32(i + j);
                let u_im = imag_parts.read_f32(i + j);

                let x_half_re = real_parts.read_f32(i + j + len _/ 2);
                let x_half_im = imag_parts.read_f32(i + j + len _/ 2);
                let v_re = x_half_re * w_re - x_half_im * w_im;
                let v_im = x_half_re * w_im + x_half_im * w_re;

                real_parts.write_f32(i + j, u_re + v_re);
                imag_parts.write_f32(i + j, u_im + v_im);

                real_parts.write_f32(i + j + len _/ 2, u_re - v_re);
                imag_parts.write_f32(i + j + len _/ 2, u_im - v_im);

                let next_w_re = w_re * wlen_re - w_im * wlen_im;
                let next_w_im = w_re * wlen_im + w_im * wlen_re;
                w_re = next_w_re;
                w_im = next_w_im;

                j = j + 1;
            }
            i = i + len;
        }
        len = len * 2;
    }

    if (inverse) {
        for (let var k = 0; k < n; ++k) {
            real_parts.write_f32(k, real_parts.read_f32(k) / n);
            imag_parts.write_f32(k, imag_parts.read_f32(k) / n);
        }
    }
}

// Function to apply a Hanning window to a buffer
fun hanning_window(buffer) {
    let n = buffer.len _/ 4;
    for (let var i = 0; i < n; ++i) {
        let multiplier = 0.5 * (1.0 - (2.0 * PI * i / (n - 1)).cos());
        buffer.write_f32(i, buffer.read_f32(i) * multiplier);
    }
}

fun mel_bins(real_parts, imag_parts, num_bins, min_freq, max_freq, fft_size, sample_rate) {
    // This function could be optimized by pre-calculating and caching the fft_bins array.
    let fft_bins = Array.with_size(num_bins + 2, 0);
    for (let var i = 0; i < fft_bins.len; ++i) {
        let freq = min_freq * (max_freq/min_freq).pow(i.to_f() / (num_bins + 1).to_f());
        fft_bins[i] = (freq * fft_size / sample_rate).floor();
    }

    let magnitudes = Array.with_size(num_bins, 0.0);
    for (let var band_idx = 0; band_idx < num_bins; ++band_idx) {
        let var band_magnitude = 0.0;
        let start_bin = fft_bins[band_idx];
        let center_bin = fft_bins[band_idx + 1];
        let end_bin = fft_bins[band_idx + 2];

        let max_bin = (fft_size / 2) - 1;
        if (start_bin > max_bin) continue;

        for (let var bin = start_bin; bin <= end_bin; ++bin) {
            if (bin > max_bin) break;

            let re = real_parts.read_f32(bin);
            let im = imag_parts.read_f32(bin);
            let magnitude = (re * re + im * im).sqrt();

            let var weight = 0.0;
            if (bin >= start_bin && bin <= center_bin) {
                if (center_bin - start_bin > 0) {
                    weight = (bin - start_bin).to_f() / (center_bin - start_bin);
                } else if (bin == center_bin) {
                    weight = 1.0;
                }
            } else if (bin > center_bin && bin <= end_bin) {
                if (end_bin - center_bin > 0) {
                    weight = (end_bin - bin).to_f() / (end_bin - center_bin);
                }
            }
            band_magnitude = band_magnitude + magnitude * weight;
        }
        magnitudes[band_idx] = band_magnitude;
    }

    return magnitudes;
}

fun main() {
    let window_id = $window_create(WINDOW_WIDTH, WINDOW_HEIGHT, "Word Detector", 0);
    let audio_input_device_id = $audio_open_input(SAMPLE_RATE, NUM_CHANNELS);

    let real_parts = ByteArray.with_size(FFT_SIZE * 4);
    let imag_parts = ByteArray.with_size(FFT_SIZE * 4);
    imag_parts.zero_fill();

    let frame_buffer = ByteArray.with_size(WINDOW_WIDTH * WINDOW_HEIGHT * 4);

    let var running = true;
    let var recording = false;
    let var waiting_for_label = false;
    let var recorded_frames = [];
    let training_pos = [];
    let training_neg = [];

    while (running) {
        if (recording) {
            $audio_read_samples(audio_input_device_id, FFT_SIZE, real_parts, 0);
            imag_parts.zero_fill();
            hanning_window(real_parts);
            fft(real_parts, imag_parts, false);
            let magnitudes = mel_bins(real_parts, imag_parts, NUM_MEL_BINS, MIN_FREQ, MAX_FREQ, FFT_SIZE, SAMPLE_RATE);
            recorded_frames.push(magnitudes);
        }

        // Basic visualization
        frame_buffer.zero_fill();
        if (recording) {
            // Draw a red circle to indicate recording
            let cx = WINDOW_WIDTH - 30;
            let cy = 30;
            let radius = 20;
            for (let var y = cy - radius; y < cy + radius; ++y) {
                for (let var x = cx - radius; x < cx + radius; ++x) {
                    let dx = x - cx;
                    let dy = y - cy;
                    if (dx*dx + dy*dy < radius*radius) {
                        let pixel_idx = (y * WINDOW_WIDTH + x);
                        frame_buffer.write_u32(pixel_idx, rgb32(255, 0, 0));
                    }
                }
            }
        } else if (waiting_for_label) {
            // Draw a yellow circle to indicate waiting for label
            let cx = WINDOW_WIDTH - 30;
            let cy = 30;
            let radius = 20;
            for (let var y = cy - radius; y < cy + radius; ++y) {
                for (let var x = cx - radius; x < cx + radius; ++x) {
                    let dx = x - cx;
                    let dy = y - cy;
                    if (dx*dx + dy*dy < radius*radius) {
                        let pixel_idx = (y * WINDOW_WIDTH + x);
                        frame_buffer.write_u32(pixel_idx, rgb32(255, 255, 0));
                    }
                }
            }
        }

        // Display counts
        // Note: This part is not implemented yet, we need a font rendering utility
        // $draw_text("Positive: " + training_pos.len.to_s(), 10, 10, rgb32(0, 255, 0));
        // $draw_text("Negative: " + training_neg.len.to_s(), 10, 30, rgb32(255, 0, 0));


        $window_draw_frame(window_id, frame_buffer);

        let event = $actor_poll();
        if (event instanceof UIEvent) {
            if (event.kind == "CLOSE_WINDOW" || event.key == "ESCAPE") {
                running = false;
            }

            if (event.kind == "KEY_DOWN") {
                if (event.key == "SPACE") {
                    recording = !recording;
                    if (!recording && recorded_frames.len > 0) {
                        $println("Recording stopped. Press P for positive, N for negative.");
                        waiting_for_label = true;
                    } else if (recording) {
                        $println("Recording started...");
                        recorded_frames = [];
                        waiting_for_label = false;
                    }
                } else if (waiting_for_label) {
                    if (event.key == "P") {
                        training_pos.push(recorded_frames);
                        $println("Saved as positive example. Total positive: " + training_pos.len.to_s());
                        recorded_frames = [];
                        waiting_for_label = false;
                    } else if (event.key == "N") {
                        training_neg.push(recorded_frames);
                        $println("Saved as negative example. Total negative: " + training_neg.len.to_s());
                        recorded_frames = [];
                        waiting_for_label = false;
                    }
                }
            }
        }
    }
}

main();
