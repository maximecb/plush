// Constants
let SAMPLE_RATE = 44100;
let NUM_CHANNELS = 1;
let WINDOW_WIDTH = 400;
let WINDOW_HEIGHT = 300;
let FFT_SIZE = 512; // Must be a power of 2
let NUM_MEL_BINS = 32;
let PI = 3.141592653589793;

let MIN_FREQ = 300.0;
let MAX_FREQ = 3500.0;

let MAX_FRAMES = 64;
let HIDDEN_SIZE = 64;
let LEARNING_RATE = 0.01;
let INPUT_SIZE = MAX_FRAMES * NUM_MEL_BINS;
let OUTPUT_SIZE = 1;
let DETECTION_THRESHOLD = 0.9;
let NOISE_MAGNITUDE = 0.03;
let GRADIENT_CLIP_THRESHOLD = 1.0;
let MAX_ZERO_FRAMES_TO_ADD = 20;

// Helper function to convert RGB values to a 32-bit color
fun rgb32(r, g, b) {
    // The alpha channel is set to 0xFF (fully opaque)
    return 0xFF000000 | (r << 16) | (g << 8) | b;
}

// --- Pseudo-Random Number Generator (LCG) ---
let var lcg_seed = 1;

fun rand_init(seed) {
    lcg_seed = seed & 0x7FFFFFFF;
}

fun rand_float() {
    lcg_seed = (lcg_seed * 1103515245 + 12345) & 0x7FFFFFFF;
    return (lcg_seed.to_f() / 0x7FFFFFFF.to_f()) - 0.5;
}

fun random_matrix(rows, cols) {
    let m = Array.with_size(rows, nil);
    for (let var r = 0; r < rows; ++r) {
        let row = Array.with_size(cols, 0.0);
        for (let var c = 0; c < cols; ++c) {
            row[c] = rand_float();
        }
        m[r] = row;
    }
    return m;
}

fun random_vector(size) {
    let v = Array.with_size(size, 0.0);
    for (let var i = 0; i < size; ++i) {
        v[i] = rand_float();
    }
    return v;
}

// --- Matrix/Vector Math ---
fun mat_vec_mult(m, v) {
    let rows = m.len;
    let cols = m[0].len;
    assert(cols == v.len);
    let result = Array.with_size(rows, 0.0);
    for (let var r = 0; r < rows; ++r) {
        let var sum = 0.0;
        for (let var c = 0; c < cols; ++c) {
            sum = sum + m[r][c] * v[c];
        }
        result[r] = sum;
    }
    return result;
}

fun vec_add(v1, v2) {
    assert(v1.len == v2.len);
    let result = Array.with_size(v1.len, 0.0);
    for (let var i = 0; i < v1.len; ++i) {
        result[i] = v1[i] + v2[i];
    }
    return result;
}

fun vec_sub(v1, v2) {
    assert(v1.len == v2.len);
    let result = Array.with_size(v1.len, 0.0);
    for (let var i = 0; i < v1.len; ++i) {
        result[i] = v1[i] - v2[i];
    }
    return result;
}

fun vec_elem_mult(v1, v2) {
    assert(v1.len == v2.len);
    let result = Array.with_size(v1.len, 0.0);
    for (let var i = 0; i < v1.len; ++i) {
        result[i] = v1[i] * v2[i];
    }
    return result;
}

fun vec_outer_prod(v1, v2) {
    let m = Array.with_size(v1.len, nil);
    for (let var r = 0; r < v1.len; ++r) {
        let row = Array.with_size(v2.len, 0.0);
        for (let var c = 0; c < v2.len; ++c) {
            row[c] = v1[r] * v2[c];
        }
        m[r] = row;
    }
    return m;
}

fun mat_transpose(m) {
    let rows = m.len;
    let cols = m[0].len;
    let t = Array.with_size(cols, nil);
    for (let var c = 0; c < cols; ++c) {
        let row = Array.with_size(rows, 0.0);
        for (let var r = 0; r < rows; ++r) {
            row[r] = m[r][c];
        }
        t[c] = row;
    }
    return t;
}

fun mat_update(m, grad, learning_rate) {
    let rows = m.len;
    let cols = m[0].len;
    for (let var r = 0; r < rows; ++r) {
        for (let var c = 0; c < cols; ++c) {
            m[r][c] = m[r][c] - learning_rate * grad[r][c];
        }
    }
}

fun vec_update(v, grad, learning_rate) {
    for (let var i = 0; i < v.len; ++i) {
        v[i] = v[i] - learning_rate * grad[i];
    }
}

// --- Activation Functions ---
fun relu(v) {
    let result = Array.with_size(v.len, 0.0);
    for (let var i = 0; i < v.len; ++i) {
        result[i] = v[i].max(0.0);
    }
    return result;
}

fun relu_derivative(v) {
    let result = Array.with_size(v.len, 0.0);
    for (let var i = 0; i < v.len; ++i) {
        if (v[i] > 0.0) {
            result[i] = 1.0;
        } else {
            result[i] = 0.0;
        }
    }
    return result;
}

// --- MLP Definition ---
class MLP {
    init(self, input_size, hidden_size, output_size) {
        self.W1 = random_matrix(hidden_size, input_size);
        self.b1 = random_vector(hidden_size);
        self.W2 = random_matrix(output_size, hidden_size);
        self.b2 = random_vector(output_size);
        self.z1 = nil;
        self.a1 = nil;
    }

    forward(self, x) {
        self.z1 = vec_add(mat_vec_mult(self.W1, x), self.b1);
        self.a1 = relu(self.z1);
        let z2 = vec_add(mat_vec_mult(self.W2, self.a1), self.b2);
        let y_pred = z2;
        return y_pred;
    }

    backward(self, x, y_true, y_pred) {
        let d_loss = vec_sub(y_pred, y_true);
        let d_W2 = vec_outer_prod(d_loss, self.a1);
        let d_b2 = d_loss;
        let W2_T = mat_transpose(self.W2);
        let d_a1 = mat_vec_mult(W2_T, d_loss);
        let d_z1 = vec_elem_mult(d_a1, relu_derivative(self.z1));
        let d_W1 = vec_outer_prod(d_z1, x);
        let d_b1 = d_z1;
        return [d_W1, d_b1, d_W2, d_b2];
    }
}

fun update(mlp, grads, learning_rate) {
    let d_W1 = grads[0];
    let d_b1 = grads[1];
    let d_W2 = grads[2];
    let d_b2 = grads[3];

    // Apply gradient clipping
    for (let var r = 0; r < d_W1.len; ++r) {
        for (let var c = 0; c < d_W1[0].len; ++c) {
            d_W1[r][c] = d_W1[r][c].max(-GRADIENT_CLIP_THRESHOLD).min(GRADIENT_CLIP_THRESHOLD);
        }
    }
    for (let var i = 0; i < d_b1.len; ++i) {
        d_b1[i] = d_b1[i].max(-GRADIENT_CLIP_THRESHOLD).min(GRADIENT_CLIP_THRESHOLD);
    }
    for (let var r = 0; r < d_W2.len; ++r) {
        for (let var c = 0; c < d_W2[0].len; ++c) {
            d_W2[r][c] = d_W2[r][c].max(-GRADIENT_CLIP_THRESHOLD).min(GRADIENT_CLIP_THRESHOLD);
        }
    }
    for (let var i = 0; i < d_b2.len; ++i) {
        d_b2[i] = d_b2[i].max(-GRADIENT_CLIP_THRESHOLD).min(GRADIENT_CLIP_THRESHOLD);
    }

    mat_update(mlp.W1, d_W1, learning_rate);
    vec_update(mlp.b1, d_b1, learning_rate);
    mat_update(mlp.W2, d_W2, learning_rate);
    vec_update(mlp.b2, d_b2, learning_rate);
}

// Function to perform in-place iterative FFT (Cooley-Tukey)
fun fft(real_parts, imag_parts, inverse) {
    let n = real_parts.len _/ 4;
    if (n == 0) {
        return;
    }
    let var i = 0;
    let var j = 0;
    while (i < n) {
        if (j > i) {
            let temp_re = real_parts.read_f32(i);
            real_parts.write_f32(i, real_parts.read_f32(j));
            real_parts.write_f32(j, temp_re);
            let temp_im = imag_parts.read_f32(i);
            imag_parts.write_f32(i, imag_parts.read_f32(j));
            imag_parts.write_f32(j, temp_im);
        }
        let var m = n _/ 2;
        while (m >= 1 && j >= m) {
            j = j - m;
            m = m _/ 2;
        }
        j = j + m;
        i = i + 1;
    }
    let var len = 2;
    while (len <= n) {
        let var ang = 2.0 * PI / len;
        if (inverse) {
            ang = -ang;
        }
        let wlen_re = ang.cos();
        let wlen_im = ang.sin();
        let var i = 0;
        while (i < n) {
            let var w_re = 1.0;
            let var w_im = 0.0;
            let var j = 0;
            while (j < len _/ 2) {
                let u_re = real_parts.read_f32(i + j);
                let u_im = imag_parts.read_f32(i + j);
                let x_half_re = real_parts.read_f32(i + j + len _/ 2);
                let x_half_im = imag_parts.read_f32(i + j + len _/ 2);
                let v_re = x_half_re * w_re - x_half_im * w_im;
                let v_im = x_half_re * w_im + x_half_im * w_re;
                real_parts.write_f32(i + j, u_re + v_re);
                imag_parts.write_f32(i + j, u_im + v_im);
                real_parts.write_f32(i + j + len _/ 2, u_re - v_re);
                imag_parts.write_f32(i + j + len _/ 2, u_im - v_im);
                let next_w_re = w_re * wlen_re - w_im * wlen_im;
                let next_w_im = w_re * wlen_im + w_im * wlen_re;
                w_re = next_w_re;
                w_im = next_w_im;
                j = j + 1;
            }
            i = i + len;
        }
        len = len * 2;
    }
    if (inverse) {
        for (let var k = 0; k < n; ++k) {
            real_parts.write_f32(k, real_parts.read_f32(k) / n);
            imag_parts.write_f32(k, imag_parts.read_f32(k) / n);
        }
    }
}

fun hanning_window(buffer) {
    let n = buffer.len _/ 4;
    for (let var i = 0; i < n; ++i) {
        let multiplier = 0.5 * (1.0 - (2.0 * PI * i / (n - 1)).cos());
        buffer.write_f32(i, buffer.read_f32(i) * multiplier);
    }
}

fun mel_bins(real_parts, imag_parts, num_bins, min_freq, max_freq, fft_size, sample_rate) {
    let fft_bins = Array.with_size(num_bins + 2, 0);
    for (let var i = 0; i < fft_bins.len; ++i) {
        let freq = min_freq * (max_freq/min_freq).pow(i.to_f() / (num_bins + 1).to_f());
        fft_bins[i] = (freq * fft_size / sample_rate).floor();
    }
    let magnitudes = Array.with_size(num_bins, 0.0);
    for (let var band_idx = 0; band_idx < num_bins; ++band_idx) {
        let var band_magnitude = 0.0;
        let start_bin = fft_bins[band_idx];
        let center_bin = fft_bins[band_idx + 1];
        let end_bin = fft_bins[band_idx + 2];
        let max_bin = (fft_size / 2) - 1;
        if (start_bin > max_bin) continue;
        for (let var bin = start_bin; bin <= end_bin; ++bin) {
            if (bin > max_bin) break;
            let re = real_parts.read_f32(bin);
            let im = imag_parts.read_f32(bin);
            let magnitude = (re * re + im * im).sqrt();
            let var weight = 0.0;
            if (bin >= start_bin && bin <= center_bin) {
                if (center_bin - start_bin > 0) {
                    weight = (bin - start_bin).to_f() / (center_bin - start_bin);
                } else if (bin == center_bin) {
                    weight = 1.0;
                }
            } else if (bin > center_bin && bin <= end_bin) {
                if (end_bin - center_bin > 0) {
                    weight = (end_bin - bin).to_f() / (end_bin - center_bin);
                }
            }
            band_magnitude = band_magnitude + magnitude * weight;
        }
        magnitudes[band_idx] = band_magnitude;
    }
    return magnitudes;
}

fun flatten_and_pad(frames, max_frames, num_bins) {
    let input_size = max_frames * num_bins;
    let flat = Array.with_size(input_size, 0.0);
    let num_frames = frames.len.min(max_frames);

    // Write frames in reverse order, so the most recent frames are at the end of the flattened array
    for (let var i = 0; i < num_frames; ++i) {
        let frame = frames[num_frames - 1 - i]; // Get frames in reverse chronological order
        let flat_start_idx = (max_frames - 1 - i) * num_bins; // Calculate target index in flat array
        for (let var j = 0; j < num_bins; ++j) {
            flat[flat_start_idx + j] = frame[j];
        }
    }

    return flat;
}

fun rand_int(min, max) {
    lcg_seed = (lcg_seed * 1103515245 + 12345) & 0x7FFFFFFF; // Update seed
    // Scale the integer lcg_seed (0 to 0x7FFFFFFF) to the range [min, max]
    // (max - min + 1) is the size of the range
    return min + (lcg_seed % (max - min + 1));
}

fun training_actor(detection_actor_id) {
    rand_init($time_current_ms());
    let mlp = MLP(INPUT_SIZE, HIDDEN_SIZE, OUTPUT_SIZE);

    let training_data = [];
    let var iteration_count = 0;
    let var positive_examples_count = 0;
    let var negative_examples_count = 0;

    while (true) {
        let msg = $actor_poll();
        if (msg != nil) {
            training_data.push(msg);
            if (msg[1] == 1.0) {
                positive_examples_count = positive_examples_count + 1;
            } else {
                negative_examples_count = negative_examples_count + 1;
            }
            $println("Positive samples: " + positive_examples_count.to_s() + ", negative samples: " + negative_examples_count.to_s());
        }

        if (training_data.len > 0) {
            let idx = rand_int(0, training_data.len - 1);
            let sample = training_data[idx];
            let frames = sample[0];
            let label = sample[1];

            let var current_frames = frames;

            // For negative examples, randomly truncate the frames
            if (label == 0.0 && frames.len > 1) {
                let max_len = frames.len;
                let var start_idx = rand_int(0, max_len - 1);
                let var end_idx = rand_int(start_idx, max_len - 1);
                if (start_idx == end_idx) {
                    // Ensure at least one frame is selected
                    end_idx = start_idx + 1;
                    if (end_idx > max_len) end_idx = max_len;
                }

                let truncated_len = end_idx - start_idx;
                let truncated_frames = Array.with_size(truncated_len, nil);
                for (let var i = 0; i < truncated_len; ++i) {
                    truncated_frames[i] = frames[start_idx + i];
                }
                current_frames = truncated_frames;
            }

            // For negative examples, randomly append zero frames
            if (label == 0.0 && MAX_ZERO_FRAMES_TO_ADD > 0) {
                let num_zero_frames = rand_int(0, MAX_ZERO_FRAMES_TO_ADD);
                if (num_zero_frames > 0) {
                    let zero_frame = Array.with_size(NUM_MEL_BINS, 0.0);
                    for (let var i = 0; i < num_zero_frames; ++i) {
                        current_frames.push(zero_frame);
                    }
                }
            }

            let x = flatten_and_pad(current_frames, MAX_FRAMES, NUM_MEL_BINS);

            // Apply random scaling for data augmentation
            let scale_factor = 1.0 + (rand_float() * 0.2);
            for (let var i = 0; i < x.len; ++i) {
                x[i] = x[i] * scale_factor;
            }

            // Add some noise for data augmentation
            for (let var i = 0; i < x.len; ++i) {
                x[i] = x[i] + rand_float() * NOISE_MAGNITUDE;
            }

            let y_true = [label];

            let y_pred = mlp.forward(x);
            let grads = mlp.backward(x, y_true, y_pred);
            update(mlp, grads, LEARNING_RATE);

            let var loss = (y_pred[0] - y_true[0]).pow(2.0);
            //$println("Loss: " + loss.to_s()); // Commented out for less console spam

            if (iteration_count % 1 == 0) {
                $println("Loss: " + loss.format_decimals(9));
            }

            iteration_count = iteration_count + 1;
            if (iteration_count % 100 == 0) {
                // Send the current model to the detection actor
                $println("Sending model update to detection actor.");
                $println("Loss: " + loss.format_decimals(9));
                $actor_send(detection_actor_id, mlp);
            }
        }

        $actor_sleep(10);
    }
}

fun detection_actor() {
    let var current_mlp = nil;
    let var frame_buffer = []; // To store recent magnitudes

    while (true) {
        let msg = $actor_poll(); // Blocks until a message is received

        if (msg instanceof MLP) {
            // Received a new MLP model from the training actor
            current_mlp = msg;
            $println("Detection actor received new MLP model.");
            continue;
        }

        if (msg instanceof Array) {
            // Received magnitudes from the main actor
            let magnitudes = msg;
            frame_buffer.push(magnitudes);

            // Keep only the latest MAX_FRAMES
            if (frame_buffer.len > MAX_FRAMES) {
                // If buffer is full, remove the oldest frame (at index 0)
                // and add the new one at the end.
                // Plush arrays don't have a direct slice/shift, so we'll rebuild.
                let new_frame_buffer = Array.with_size(MAX_FRAMES, nil);
                for (let var i = 0; i < MAX_FRAMES - 1; ++i) {
                    new_frame_buffer[i] = frame_buffer[i + 1];
                }
                new_frame_buffer[MAX_FRAMES - 1] = magnitudes;
                frame_buffer = new_frame_buffer;
            }
            assert(frame_buffer.len <= MAX_FRAMES);
        }

        // Only make a prediction if we have enough frames
        if (msg == nil && current_mlp != nil && frame_buffer.len == MAX_FRAMES) {
            let x = flatten_and_pad(frame_buffer, MAX_FRAMES, NUM_MEL_BINS);
            let y_pred = current_mlp.forward(x);

            if (y_pred[0] > DETECTION_THRESHOLD) {
                $println("DETECTED");
            }
        }
    }
}

fun main() {
    let detector_id = $actor_spawn(detection_actor);
    let trainer_id = $actor_spawn(|| training_actor(detector_id));

    let window_id = $window_create(WINDOW_WIDTH, WINDOW_HEIGHT, "Word Detector", 0);
    let audio_input_device_id = $audio_open_input(SAMPLE_RATE, NUM_CHANNELS);

    let real_parts = ByteArray.with_size(FFT_SIZE * 4);
    let imag_parts = ByteArray.with_size(FFT_SIZE * 4);
    imag_parts.zero_fill();

    let frame_buffer = ByteArray.with_size(WINDOW_WIDTH * WINDOW_HEIGHT * 4);

    let var running = true;
    let var recording = false;
    let var recorded_frames = [];

    while (running) {
        $audio_read_samples(audio_input_device_id, FFT_SIZE, real_parts, 0);
        imag_parts.zero_fill();
        hanning_window(real_parts);
        fft(real_parts, imag_parts, false);
        let magnitudes = mel_bins(real_parts, imag_parts, NUM_MEL_BINS, MIN_FREQ, MAX_FREQ, FFT_SIZE, SAMPLE_RATE);
        $actor_send(detector_id, magnitudes);

        if (recording) {
            recorded_frames.push(magnitudes);
        }

        frame_buffer.zero_fill();
        if (recording) {
            let cx = WINDOW_WIDTH - 30;
            let cy = 30;
            let radius = 20;
            for (let var y = cy - radius; y < cy + radius; ++y) {
                for (let var x = cx - radius; x < cx + radius; ++x) {
                    let dx = x - cx;
                    let dy = y - cy;
                    if (dx*dx + dy*dy < radius*radius) {
                        let pixel_idx = (y * WINDOW_WIDTH + x);
                        frame_buffer.write_u32(pixel_idx, rgb32(255, 0, 0));
                    }
                }
            }
        }

        $window_draw_frame(window_id, frame_buffer);

        let event = $actor_poll();
        if (event instanceof UIEvent) {
            if (event.kind == "CLOSE_WINDOW" || event.key == "ESCAPE") {
                running = false;
            }

            if (event.kind == "KEY_DOWN") {
                if (event.key == "SPACE") {
                    recording = !recording;
                    if (!recording && recorded_frames.len > 0) {
                        $println("Recording stopped. Press P for positive, N for negative.");
                    } else if (recording) {
                        $println("Recording started...");
                        recorded_frames = [];
                    }
                } else if (recorded_frames.len > 0) {
                    if (event.key == "P") {
                        $println("Saved as positive example.");
                        $actor_send(trainer_id, [recorded_frames, 1.0]);
                        recorded_frames = [];
                        recording = false; // Stop recording when labeled
                    } else if (event.key == "N") {
                        $println("Saved as negative example.");
                        $actor_send(trainer_id, [recorded_frames, 0.0]);
                        recorded_frames = [];
                        recording = false; // Stop recording when labeled
                    }
                }
            }
        }
    }
}

main();
