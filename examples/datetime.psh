// Parses a timestamp in milliseconds from the UNIX epoch into a date/time object.

fun pad_zero(n) {
    if (n < 10) {
        return "0" + n.to_s();
    }
    return n.to_s();
}

class DateTime
{
    init(self, timestamp_ms, utc_offset_hours) {
        // Helper function to check for leap years
        fun is_leap(year) {
            return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
        }

        let secs_in_day = 86400;
        let timestamp_secs = (timestamp_ms / 1000).floor();

        // Apply UTC offset
        let adjusted_secs = timestamp_secs + utc_offset_hours * 3600;

        // Calculate date components
        let var days = (adjusted_secs / secs_in_day).floor();
        self.days_since_epoch = days;
        let var year = 1970;
        let var days_in_year = 365;
        while (days >= days_in_year) {
            days = days - days_in_year;
            year = year + 1;
            days_in_year = is_leap(year) ? 366 : 365;
        }

        let var month = 1;
        let var days_in_month = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        if (is_leap(year)) {
            days_in_month[2] = 29;
        }

        while (days >= days_in_month[month]) {
            days = days - days_in_month[month];
            month = month + 1;
        }

        let day = days + 1;

        // Calculate time components
        let secs_today = adjusted_secs % secs_in_day;
        let hour = (secs_today / 3600).floor();
        let minute = ((secs_today % 3600) / 60).floor();
        let second = secs_today % 60;

        self.year = year;
        self.month = month;
        self.day = day;
        self.hour = hour;
        self.minute = minute;
        self.second = second;
    }

    to_s(self) {
        return (
            self.year.to_s() + "-" +
            pad_zero(self.month) + "-" +
            pad_zero(self.day) + " " +
            pad_zero(self.hour) + ":" +
            pad_zero(self.minute) + ":" +
            pad_zero(self.second)
        );
    }

    // Produce a string with the format YYYY-MM-DD
    date_s(self) {
        return (
            self.year.to_s() + "-" +
            pad_zero(self.month) + "-" +
            pad_zero(self.day)
        );
    }

    weekday_s(self) {
        let day_idx = (self.days_since_epoch + 4) % 7;
        let weekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
        return weekdays[day_idx];
    }

    part_of_day(self) {
        if (self.hour < 6)
            return "night";
        if (self.hour < 12)
            return "morning";
        if (self.hour == 12)
            return "noon";
        if (self.hour < 18)
            return "afternoon";
        if (self.hour < 22)
            return "evening";
        return "night";
    }
}

fun test() {
    $println("\nRunning tests...");

    fun assert_equal(actual, expected, message) {
        if (actual != expected) {
            $println("Assertion failed: " + message);
            $println("  Expected: " + expected);
            $println("  Actual:   " + actual);
            $exit(-1);
        } else {
            $println("Test passed: " + message);
        }
    }

    let current_time_ms = $time_current_ms();
    let utc_offset = -4; // Example: EDT
    let datetime = DateTime(current_time_ms, utc_offset);

    $println("Current timestamp (ms): " + current_time_ms.to_s());
    $println("Parsed Date/Time (UTC" + utc_offset.to_s() + "):");
    $println("  Year: " + datetime.year.to_s());
    $println("  Month: " + datetime.month.to_s());
    $println("  Day: " + datetime.day.to_s());
    $println("  Hour: " + datetime.hour.to_s());
    $println("  Minute: " + datetime.minute.to_s());
    $println("  Second: " + datetime.second.to_s());
    $println("  Part of day: " + datetime.part_of_day());

    // Test case 1: Unix epoch zero
    let dt1 = DateTime(0, 0);
    assert_equal(dt1.to_s(), "1970-01-01 00:00:00", "Unix epoch zero");
    assert_equal(dt1.date_s(), "1970-01-01", "Unix epoch zero date");

    // Test case 2: A known date
    // 2023-10-26 10:00:00 UTC is 1698314400000 ms
    let dt2 = DateTime(1698314400000, 0);
    assert_equal(dt2.to_s(), "2023-10-26 10:00:00", "A known date");
    assert_equal(dt2.weekday_s(), "Thursday", "Day of week for a known date");

    // Test case 3: Another known date with offset
    // 2023-10-26 10:00:00 UTC is 2023-10-26 06:00:00 EDT (UTC-4)
    let dt3 = DateTime(1698314400000, -4);
    assert_equal(dt3.to_s(), "2023-10-26 06:00:00", "A known date with offset");

    // Test case 4: A leap year
    // 2020-02-29 12:00:00 UTC is 1582977600000 ms
    let dt4 = DateTime(1582977600000, 0);
    assert_equal(dt4.to_s(), "2020-02-29 12:00:00", "A leap year");
}

if ($MAIN_UNIT) {
    test();
}
