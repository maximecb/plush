
// 808-style Drum Machine
//
// This example demonstrates procedural audio synthesis to create a simple
// drum pattern with a kick, snare, and hi-hat.

let SAMPLE_RATE = 44100;
let TEMPO = 120.0; // BPM

// --- Sequencer Pattern ---
// Each row is an instrument pattern across all steps.
// pattern[0] = kick, pattern[1] = snare, pattern[2] = hi-hat, pattern[3] = clap
let pattern = [
    // Kick pattern
    [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
    // Snare pattern
    [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0],
    // Hi-hat pattern
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    // Clap pattern
    [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
];

// --- Predefined Patterns ---
let kick_patterns = [
    [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], // Four on the floor
    [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], // 8th notes
    [1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0], // Syncopated
    [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], // Simple kick
    [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0], // Driving kick
];

let snare_patterns = [
    [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], // On 2 and 4
    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], // Just on 2 and 4
    [0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1], // With ghost notes
    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], // Simple snare
    [0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0], // Snare roll
];

let hat_patterns = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 16th notes
    [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], // 8th notes
    [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], // Offbeats
    [1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1], // Varied 16th
    [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], // Off-beat 8th
];

let clap_patterns = [
    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], // On 2 and 4
    [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], // Syncopated
    [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], // Simple clap
    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], // Off-beat clap
];

// --- Pseudo-Random Number Generator (LCG) ---
let var lcg_seed = $time_current_ms();
fun rand_init(seed) {
    lcg_seed = seed & 0x7FFFFFFF;
}

fun rand_float() {
    lcg_seed = (lcg_seed * 1103515245 + 12345) & 0x7FFFFFFF;
    return (lcg_seed.to_f() / 0x7FFFFFFF.to_f()) * 2.0 - 1.0; // -1.0 to 1.0
}

fun rand_int(max_val) {
    lcg_seed = (lcg_seed * 1103515245 + 12345) & 0x7FFFFFFF;
    return lcg_seed % max_val;
}

// --- Synthesis State ---
let PI = 3.1415926535;

// Kick state
let var kick_phase = 0.0;
let var kick_amp_env = 0.0;
let var kick_pitch_env = 0.0;
let KICK_START_FREQ = 200.0;
let KICK_END_FREQ = 50.0;
let KICK_DECAY = 0.2; // seconds

// Snare state
let var snare_amp_env = 0.0;
let var snare_noise = 0.0;
let SNARE_DECAY = 0.15; // seconds

// Snare tone component
let var snare_tone_phase = 0.0;
let var snare_tone_amp_env = 0.0;
let var snare_tone_freq_env = 0.0;
let SNARE_TONE_START_FREQ = 200.0;
let SNARE_TONE_END_FREQ = 100.0;
let SNARE_TONE_DECAY = 0.12; // seconds

// Hi-hat state
let var hat_amp_env = 0.0;
let var hat_noise = 0.0;
let HAT_DECAY = 0.05; // seconds

// Clap state
let CLAP_COUNT = 4; // Number of individual claps
let CLAP_DELAY_SAMPLES = (0.008 * SAMPLE_RATE).floor(); // Delay between claps in samples
let var clap_amp_envs = Array.with_size(CLAP_COUNT, 0.0);
let var clap_noises = Array.with_size(CLAP_COUNT, 0.0);
let CLAP_DECAY = 0.08; // seconds

// --- Sequencer State ---
let var step_idx = 0;
let samples_per_step = ((60.0 / TEMPO) / 4.0 * SAMPLE_RATE).floor(); // 16th notes
let var sample_in_step = 0;
let var total_steps = 0;

// Variables to track the last selected pattern index for each instrument
let var last_kick_pattern_idx = -1;
let var last_snare_pattern_idx = -1;
let var last_hat_pattern_idx = -1;
let var last_clap_pattern_idx = -1;

let var clap_sample_counter = 0;

// --- Pattern Mutation ---
fun mutate_pattern() {
    let instrument_to_change = rand_int(4); // 0: kick, 1: snare, 2: hat, 3: clap
    let num_steps = pattern[0].len; // Assuming all instrument patterns have the same length

    if (instrument_to_change == 0) {
        let var new_pattern_idx = rand_int(kick_patterns.len);
        // Ensure the new pattern is different from the last one
        while (new_pattern_idx == last_kick_pattern_idx && kick_patterns.len > 1) {
            new_pattern_idx = rand_int(kick_patterns.len);
        }
        let new_kick_pattern = kick_patterns[new_pattern_idx];
        for (let var i = 0; i < num_steps; ++i) {
            pattern[0][i] = new_kick_pattern[i];
        }
        last_kick_pattern_idx = new_pattern_idx; // Update last selected index
        $println("Kick pattern changed.");
    } else if (instrument_to_change == 1) {
        let var new_pattern_idx = rand_int(snare_patterns.len);
        // Ensure the new pattern is different from the last one
        while (new_pattern_idx == last_snare_pattern_idx && snare_patterns.len > 1) {
            new_pattern_idx = rand_int(snare_patterns.len);
        }
        let new_snare_pattern = snare_patterns[new_pattern_idx];
        for (let var i = 0; i < num_steps; ++i) {
            pattern[1][i] = new_snare_pattern[i];
        }
        last_snare_pattern_idx = new_pattern_idx; // Update last selected index
        $println("Snare pattern changed.");
    } else if (instrument_to_change == 2) {
        let var new_pattern_idx = rand_int(hat_patterns.len);
        // Ensure the new pattern is different from the last one
        while (new_pattern_idx == last_hat_pattern_idx && hat_patterns.len > 1) {
            new_pattern_idx = rand_int(hat_patterns.len);
        }
        let new_hat_pattern = hat_patterns[new_pattern_idx];
        for (let var i = 0; i < num_steps; ++i) {
            pattern[2][i] = new_hat_pattern[i];
        }
        last_hat_pattern_idx = new_pattern_idx; // Update last selected index
        $println("Hi-hat pattern changed.");
    } else { // instrument_to_change == 3
        let var new_pattern_idx = rand_int(clap_patterns.len);
        // Ensure the new pattern is different from the last one
        while (new_pattern_idx == last_clap_pattern_idx && clap_patterns.len > 1) {
            new_pattern_idx = rand_int(clap_patterns.len);
        }
        let new_clap_pattern = clap_patterns[new_pattern_idx];
        for (let var i = 0; i < num_steps; ++i) {
            pattern[3][i] = new_clap_pattern[i];
        }
        last_clap_pattern_idx = new_pattern_idx; // Update last selected index
        $println("Clap pattern changed.");
    }
}

// --- Main Synthesis and Sequencing Logic ---

fun trigger_step(current_total_steps) {
    let kick_on = pattern[0][step_idx];
    let snare_on = pattern[1][step_idx];
    let hat_on = pattern[2][step_idx];
    let clap_on = pattern[3][step_idx];

    let current_bar = (current_total_steps / 16).floor();

    if (kick_on == 1) {
        kick_amp_env = 1.0;
        kick_pitch_env = 1.0;
    }

    if (current_bar >= 4) { // Start snare on bar 5
        if (snare_on == 1) {
            snare_amp_env = 1.0;
            snare_tone_amp_env = 1.0;
            snare_tone_freq_env = 1.0;
        }
    }

    if (current_bar >= 8) { // Start hi-hat on bar 9
        if (hat_on == 1) {
            hat_amp_env = 1.0;
        }
    }

    if (current_bar >= 12) { // Start clap on bar 13
        if (clap_on == 1) {
            for (let var i = 0; i < CLAP_COUNT; ++i) {
                clap_amp_envs[i] = 1.0;
            }
        }
    }
}

fun generate_samples(num_samples) {
    let samples = ByteArray.with_size(num_samples * 4); // 4 bytes per float32

    for (let var i = 0; i < num_samples; ++i) {
        // --- Sequencer ---
        if (sample_in_step == 0) {
            if (total_steps == 0) {
                $println("Kick starts");
            }
            if (total_steps == 64) { // Bar 5
                $println("Snare starts");
            }
            if (total_steps == 128) { // Bar 9
                $println("Hi-hat starts");
            }
            if (total_steps == 192) { // Bar 13
                $println("Clap starts");
            }

            // Mutate pattern every 4 bars, starting after all instruments are in
            if (total_steps >= 4*16*4 && total_steps % 64 == 0) {
                mutate_pattern();
            }

            // Print bar number
            if (total_steps % 16 == 0) {
                let bar_num = (total_steps / 16).floor() + 1;
                $println("Bar: " + bar_num.to_s());
            }

            trigger_step(total_steps);
        }

        // --- Synthesis ---
        let var kick_sample = 0.0;
        if (kick_amp_env > 0) {
            let freq = KICK_END_FREQ + (kick_pitch_env * (KICK_START_FREQ - KICK_END_FREQ));
            kick_phase = kick_phase + freq / SAMPLE_RATE;
            if (kick_phase >= 1.0) {
                kick_phase = kick_phase - 1.0;
            }
            kick_sample = (kick_phase * 2.0 * PI).sin() * kick_amp_env;

            kick_amp_env = kick_amp_env - (1.0 / (KICK_DECAY * SAMPLE_RATE));
            kick_pitch_env = kick_pitch_env - (1.0 / (KICK_DECAY * 0.5 * SAMPLE_RATE));
            if (kick_amp_env < 0) { kick_amp_env = 0; }
            if (kick_pitch_env < 0) { kick_pitch_env = 0; }
        }

        let var snare_sample = 0.0;
        if (snare_amp_env > 0 || snare_tone_amp_env > 0) {
            // Noise component
            snare_noise = rand_float();
            let noise_component = snare_noise * snare_amp_env;

            // Tone component
            let tone_freq = SNARE_TONE_END_FREQ + (snare_tone_freq_env * (SNARE_TONE_START_FREQ - SNARE_TONE_END_FREQ));
            snare_tone_phase = snare_tone_phase + tone_freq / SAMPLE_RATE;
            if (snare_tone_phase >= 1.0) {
                snare_tone_phase = snare_tone_phase - 1.0;
            }
            let tone_component = (snare_tone_phase * 2.0 * PI).sin() * snare_tone_amp_env;

            // Mix noise and tone
            snare_sample = (noise_component * 0.7) + (tone_component * 0.3); // Adjust mix as needed

            // Decay envelopes
            snare_amp_env = snare_amp_env - (1.0 / (SNARE_DECAY * SAMPLE_RATE));
            snare_tone_amp_env = snare_tone_amp_env - (1.0 / (SNARE_TONE_DECAY * SAMPLE_RATE));
            snare_tone_freq_env = snare_tone_freq_env - (1.0 / (SNARE_TONE_DECAY * 0.5 * SAMPLE_RATE)); // Faster freq decay

            if (snare_amp_env < 0) { snare_amp_env = 0; }
            if (snare_tone_amp_env < 0) { snare_tone_amp_env = 0; }
            if (snare_tone_freq_env < 0) { snare_tone_freq_env = 0; }
        }

        let var hat_sample = 0.0;
        if (hat_amp_env > 0) {
            hat_noise = rand_float();
            hat_sample = hat_noise * hat_amp_env;
            hat_amp_env = hat_amp_env - (1.0 / (HAT_DECAY * SAMPLE_RATE));
            if (hat_amp_env < 0) { hat_amp_env = 0; }
        }

        let var clap_sample = 0.0;
        let var any_clap_active = false;
        for (let var i = 0; i < CLAP_COUNT; ++i) {
            if (clap_amp_envs[i] > 0) {
                any_clap_active = true;
                let delay_offset = i * CLAP_DELAY_SAMPLES;
                if (clap_sample_counter >= delay_offset) {
                    // Generate new noise for each clap burst
                    clap_noises[i] = rand_float();
                    clap_sample = clap_sample + (clap_noises[i] * clap_amp_envs[i]);

                    // Decay envelope
                    clap_amp_envs[i] = clap_amp_envs[i] - (1.0 / (CLAP_DECAY * SAMPLE_RATE));
                    if (clap_amp_envs[i] < 0) { clap_amp_envs[i] = 0; }
                }
            }
        }
        if (any_clap_active) {
            clap_sample_counter = clap_sample_counter + 1;
        } else {
            clap_sample_counter = 0; // Reset when all claps are done
        }

        // --- Mixdown ---
        let final_sample = (kick_sample * 0.8 + snare_sample * 0.5 + hat_sample * 0.2 + clap_sample * 0.4);
        samples.write_f32(i, final_sample);

        // --- Advance Sequencer ---
        sample_in_step = sample_in_step + 1;
        if (sample_in_step >= samples_per_step) {
            sample_in_step = 0;
            step_idx = (step_idx + 1) % pattern.len;
            total_steps = total_steps + 1;
        }
    }

    return samples;
}

// --- Main Program ---

fun main() {
    rand_init($time_current_ms());

    // Open the audio device
    let audio_dev = $audio_open_output(SAMPLE_RATE, 1); // 1 channel (mono)
    if (audio_dev == nil) {
        $println("Failed to open audio device.");
        return;
    }

    // Create a window to allow graceful exit
    let window = $window_create(400, 200, "808 Drum Machine", 0);

    $println("Playing drum pattern... Press ESC or close the window to exit.");

    // Main event loop
    loop {
        let msg = $actor_recv();

        if (msg instanceof AudioNeeded) {
            // The audio driver needs more samples
            let samples = generate_samples(msg.num_samples);
            $audio_write_samples(audio_dev, samples);
        }
        else if (msg instanceof UIEvent) {
            if (msg.kind == 'CLOSE_WINDOW' || (msg.kind == 'KEY_DOWN' && msg.key == 'ESCAPE')) {
                break;
            }
        }
    }
}

main();
