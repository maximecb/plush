let SAMPLE_RATE = 44100;
let NUM_CHANNELS = 1;

let WIDTH = 800;
let HEIGHT = 600;

// Helper function to convert RGB values to a 32-bit color
fun rgb32(r, g, b) {
    return 0xFF_00_00_00 | (r << 16) | (g << 8) | b;
}

let BLACK = rgb32(0, 0, 0);
let RED = rgb32(255, 0, 0);
let BLUE = rgb32(50, 100, 255);
let WHITE = rgb32(255, 255, 255);
let SELECTION_COLOR = rgb32(80, 80, 80);

// Helper function to draw a rectangle (for selection highlight)
fun draw_rect(buffer, x, y, width, height, color) {
    let x_start = x.max(0);
    let y_start = y.max(0);
    let x_end = (x + width).min(WIDTH);
    let y_end = (y + height).min(HEIGHT);

    let clipped_width = x_end - x_start;

    if (clipped_width <= 0) {
        return;
    }

    for (let var j = y_start; j < y_end; ++j) {
        let start_index = j * WIDTH + x_start;
        buffer.fill_u32(start_index, clipped_width, color);
    }
}

class WavePlot {
    init(self, width, height, color) {
        self.width = width;
        self.height = height;
        self.color = color;
        self.clear_samples();
    }

    clear_samples(self) {
        self.audio_data = ByteArray.with_size(0);
        self.num_samples = 0; // Reset num_samples
        self.magnitude_buckets = Array.with_size(100, 0); // Reset magnitude buckets
        self.max_sample_range = 0.0; // Reset max_sample_range

        // Reset selection state
        self.s_idx = nil;
        self.e_idx = nil;
    }

    append_samples(self, new_samples) {
        let old_size = self.audio_data.len;
        let new_size = old_size + new_samples.len;
        self.audio_data.resize(new_size);
        self.audio_data.memcpy(old_size, new_samples, 0, new_samples.len);

        // Update num_samples
        let num_new_samples = new_samples.len _/ 4;
        self.num_samples = self.num_samples + num_new_samples;

        // Update magnitude_buckets
        for (let var i = 0; i < num_new_samples; i = i + 1) {
            let sample = new_samples.get_f32(i);
            let abs_sample = sample.abs();

            // Increment magnitude bucket
            let bucket_idx = (abs_sample * 100).floor().min(99);
            self.magnitude_buckets[bucket_idx] = self.magnitude_buckets[bucket_idx] + 1;
        }

        // Calculate 99th percentile magnitude for normalization (max_sample_range)
        let target_samples = self.num_samples * 0.99;
        let var cumulative_samples = 0;
        let var calculated_max_sample_range = 0.0;
        for (let var i = 0; i < 100; ++i) {
            cumulative_samples = cumulative_samples + self.magnitude_buckets[i];
            if (cumulative_samples >= target_samples) {
                calculated_max_sample_range = (i + 1).to_f() / 100.0;
                break;
            }
        }

        // Fallback if no samples or all samples are very small
        if (calculated_max_sample_range == 0.0) {
            self.max_sample_range = 0.01; // A small default to avoid division by zero
        } else {
            self.max_sample_range = calculated_max_sample_range * 1.20;
        }
    }

    select(self, start_norm, end_norm) {
        // If no selection, reset to nil
        if (start_norm == nil || end_norm == nil) {
            self.s_idx = nil;
            self.e_idx = nil;
            return;
        }

        // Convert normalized coordinates to sample indices
        let s_idx_raw = (start_norm * self.num_samples.to_f()).floor();
        let e_idx_raw = (end_norm * self.num_samples.to_f()).floor();

        // Ensure indices are within bounds and correctly ordered
        self.s_idx = s_idx_raw.min(e_idx_raw).max(0).min(self.num_samples);
        self.e_idx = s_idx_raw.max(e_idx_raw).max(0).min(self.num_samples);
    }

    get_selection(self) {
        if (self.s_idx == nil || self.e_idx == nil) {
            return self.audio_data;
        }

        let start_byte = self.s_idx * 4;
        let end_byte = self.e_idx * 4;
        let selection_size = end_byte - start_byte;

        let selection_data = ByteArray.with_size(selection_size);
        selection_data.memcpy(0, self.audio_data, start_byte, selection_size);

        return selection_data;
    }

    // Delete the current selection
    delete_sel(self) {
        if (self.s_idx == nil || self.e_idx == nil) {
            return;
        }

        assert(self.s_idx instanceof Int64);
        assert(self.e_idx instanceof Int64);
        let start_byte = self.s_idx * 4;
        let end_byte = self.e_idx * 4;

        let new_size = self.audio_data.len - (end_byte - start_byte);
        let new_buffer = ByteArray.with_size(new_size);

        // Copy the part before the selection
        new_buffer.memcpy(0, self.audio_data, 0, start_byte);

        // Copy the part after the selection
        new_buffer.memcpy(start_byte, self.audio_data, end_byte, self.audio_data.len - end_byte);

        self.audio_data = new_buffer;
        self.num_samples = new_size _/ 4;

        // Clear the selection
        self.select(nil, nil);
    }

    redraw(self, frame_buffer) {
        // Clear the buffer
        frame_buffer.zero_fill();

        if (self.num_samples == 0 || self.max_sample_range == 0.0) {
            return;
        }

        // Draw selection highlight first
        if (self.s_idx != nil && self.e_idx != nil) {
            // Convert sample indices to pixel coordinates for drawing
            let x1_pixel = (self.s_idx.to_f() / self.num_samples.to_f() * self.width.to_f()).floor();
            let x2_pixel = (self.e_idx.to_f() / self.num_samples.to_f() * self.width.to_f()).floor();

            let draw_x1 = x1_pixel.min(x2_pixel);
            let draw_x2 = x1_pixel.max(x2_pixel);
            let highlight_width = draw_x2 - draw_x1 + 1;

            if (highlight_width > 0) {
                draw_rect(frame_buffer, draw_x1, 0, highlight_width, self.height, SELECTION_COLOR);
            }
        }

        // For each column of the frame buffer
        for (let var i = 0; i < self.width; ++i)
        {
            let samples_per_col = (self.num_samples / self.width).max(1.0).min(200.0).floor();
            let start_idx = ((i / (self.width - 1)) * (self.num_samples - 1)).floor();
            let end_idx = (start_idx + samples_per_col).min(self.num_samples);

            // Determine the max sample value for this column
            let var max_sample = 0.0;
            for (let var k = start_idx; k < end_idx; ++k)
                max_sample = max_sample.max(self.audio_data.get_f32(k));

            // Compute the Y coordinate in the frame buffer for this sample
            let norm_v = (max_sample / self.max_sample_range).min(1.0).max(-1.0);
            let pos_v = ((1.0 + norm_v) / 2.0).min(1.0);
            let j = (pos_v * (self.height - 1)).floor();

            let mid_y = self.height _/ 2;
            let end_y = (j - mid_y).abs();
            for (let var k = mid_y - end_y; k < mid_y + end_y; ++k) {
                frame_buffer.set_u32(k * self.width + i, self.color);
            }
        }
    }
}

fun reverse_samples(ba) {
    let len = ba.len;
    let reversed_ba = ByteArray.with_size(len);
    let num_floats = len _/ 4;
    for (let var i = 0; i < num_floats; i = i + 1) {
        let val = ba.get_f32(i);
        reversed_ba.set_f32(num_floats - 1 - i, val);
    }
    return reversed_ba;
}

fun playback_actor()
{
    let audio_out = $audio_open_output(SAMPLE_RATE, NUM_CHANNELS);

    let var samples_to_play = nil;
    let var playing = false;
    let var looping = false;
    let var play_pos = 0; // in samples

    loop {
        let msg = $actor_poll();

        if (msg instanceof AudioNeeded)
        {
            let num_samples_needed = msg.num_samples;
            let silent_chunk = ByteArray.with_size(num_samples_needed * 4);
            silent_chunk.zero_fill();

            if (playing) {
                let total_samples = samples_to_play.len _/ 4;
                let samples_available = total_samples - play_pos;
                let num_samples_to_send = num_samples_needed.min(samples_available);

                if (num_samples_to_send > 0) {
                    let start_byte = play_pos * 4;
                    let num_bytes_to_send = num_samples_to_send * 4;
                    silent_chunk.memcpy(0, samples_to_play, start_byte, num_bytes_to_send);
                    play_pos = play_pos + num_samples_to_send;
                }

                if (play_pos >= total_samples) {
                    if (looping) {
                        play_pos = 0;
                    } else {
                        playing = false;
                    }
                }
            }

            $audio_write_samples(audio_out, silent_chunk);

        } else if (msg == 'PLAY') {
            playing = true;
            looping = false;
            play_pos = 0;
        } else if (msg == 'STOP') {
            playing = false;
            play_pos = 0;
        } else if (msg == 'PLAY_LOOPING') {
            playing = true;
            looping = true;
            play_pos = 0;
        } else if (msg instanceof ByteArray) {
            samples_to_play = msg;
            playing = false;
            play_pos = 0;
        }
    }
}

// --- Main Program ---
let frame_buffer = ByteArray.with_size(WIDTH * HEIGHT * 4);
let window = $window_create(WIDTH, HEIGHT, "Audio Recorder", 0);
let audio_in = $audio_open_input(SAMPLE_RATE, NUM_CHANNELS);
let wave_plot = WavePlot(WIDTH, HEIGHT, BLUE);
let var recording = false;

// Variables for mouse selection
let var is_dragging = false;
let var drag_start_x = nil;
let var drag_end_x = nil;

// Spawn the playback actor
let playback_actor_id = $actor_spawn(playback_actor);

$println("Press R to record audio or stop recording");
$println("Click and drag to select samples");
$println("Backspace: delete samples");
$println("Space: start playback");
$println("S: stop playback");
$println("L: looping playback");
$println("B: reverse looping playback");

loop {
    // --- Event Handling ---
    let msg = $actor_poll();

    if (msg instanceof UIEvent) {
        if (msg.kind == 'CLOSE_WINDOW' || (msg.kind == 'KEY_DOWN' && msg.key == 'ESCAPE')) {
            break;
        }

        if (msg.kind == 'KEY_DOWN' && (msg.key == 'DELETE' || msg.key == 'BACKSPACE')) {
            wave_plot.delete_sel();
        }

        if (msg.kind == 'KEY_DOWN' && msg.key == 'R') {
            recording = !recording;
            if (recording) {
                $println("Recording started...");
                wave_plot.clear_samples();
                wave_plot.select(nil, nil); // Clear selection on new recording
            } else {
                $println("Recording stopped.");
            }
        }

        if (msg.kind == 'KEY_DOWN' && msg.key == 'SPACE') {
            $actor_send(playback_actor_id, wave_plot.get_selection());
            $actor_send(playback_actor_id, 'PLAY');
        }

        if (msg.kind == 'KEY_DOWN' && msg.key == 'L') {
            $actor_send(playback_actor_id, wave_plot.get_selection());
            $actor_send(playback_actor_id, 'PLAY_LOOPING');
        }

        if (msg.kind == 'KEY_DOWN' && msg.key == 'B') {
            let selection = wave_plot.get_selection();
            let reversed_selection = reverse_samples(selection);
            $actor_send(playback_actor_id, reversed_selection);
            $actor_send(playback_actor_id, 'PLAY_LOOPING');
        }

        if (msg.kind == 'KEY_DOWN' && msg.key == 'S') {
            $actor_send(playback_actor_id, 'STOP');
        }

        if (msg.kind == 'MOUSE_DOWN') {
            is_dragging = true;
            drag_start_x = msg.x;
            drag_end_x = msg.x; // Start with a single point selection

            // Calculate normalized coordinates and pass to WavePlot
            let norm_start = drag_start_x.to_f() / wave_plot.width.to_f();
            let norm_end = drag_end_x.to_f() / wave_plot.width.to_f();
            wave_plot.select(norm_start, norm_end);
        }

        if (msg.kind == 'MOUSE_MOVE') {
            if (is_dragging) {
                drag_end_x = msg.x;

                // Calculate normalized coordinates and pass to WavePlot
                let norm_start = drag_start_x.to_f() / wave_plot.width.to_f();
                let norm_end = drag_end_x.to_f() / wave_plot.width.to_f();
                wave_plot.select(norm_start, norm_end);
            }
        }

        if (msg.kind == 'MOUSE_UP') {
            is_dragging = false;

            // Calculate normalized coordinates and pass to WavePlot
            let norm_start = drag_start_x.to_f() / wave_plot.width.to_f();
            let norm_end = drag_end_x.to_f() / wave_plot.width.to_f();
            wave_plot.select(norm_start, norm_end);
            $println("Selected samples: [" + wave_plot.s_idx.to_s() + ", " + wave_plot.e_idx.to_s() + "]");
        }
    }

    // Block and read a chunk of audio data
    let chunk = ByteArray.with_size(1024 * 4);
    $audio_read_samples(audio_in, 1024, chunk, 0);

    if (recording) {
        wave_plot.append_samples(chunk);
    }

    // --- Drawing ---
    wave_plot.redraw(frame_buffer);
    $window_draw_frame(window, frame_buffer);
}
