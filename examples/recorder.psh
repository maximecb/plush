let SAMPLE_RATE = 44100;
let NUM_CHANNELS = 1;

let WIDTH = 800;
let HEIGHT = 600;

// Helper function to convert RGB values to a 32-bit color
fun rgb32(r, g, b) {
    return 0xFF_00_00_00 | (r << 16) | (g << 8) | b;
}

let BLACK = rgb32(0, 0, 0);
let RED = rgb32(255, 0, 0);
let BLUE = rgb32(50, 100, 255);
let WHITE = rgb32(255, 255, 255);
let SELECTION_COLOR = rgb32(80, 80, 80);

// Helper function to draw a rectangle (for selection highlight)
fun draw_rect(buffer, x, y, width, height, color) {
    let x_start = x.max(0);
    let y_start = y.max(0);
    let x_end = (x + width).min(WIDTH);
    let y_end = (y + height).min(HEIGHT);

    let clipped_width = x_end - x_start;

    if (clipped_width <= 0) {
        return;
    }

    for (let var j = y_start; j < y_end; ++j) {
        let start_index = j * WIDTH + x_start;
        buffer.fill_u32(start_index, clipped_width, color);
    }
}

class WavePlot {
    init(self, width, height, color) {
        self.width = width;
        self.height = height;
        self.color = color;
        self.clear_samples();
    }

    clear_samples(self) {
        self.audio_data = ByteArray.with_size(0);
        self.num_samples = 0; // Reset num_samples
        self.magnitude_buckets = Array.with_size(100, 0); // Reset magnitude buckets
        self.max_sample_range = 0.0; // Reset max_sample_range

        // Reset selection state
        self.s_idx = nil;
        self.e_idx = nil;
    }

    append_samples(self, new_samples) {
        let new_size = self.audio_data.len + new_samples.len;
        let new_buffer = ByteArray.with_size(new_size);
        new_buffer.memcpy(0, self.audio_data, 0, self.audio_data.len);
        new_buffer.memcpy(self.audio_data.len, new_samples, 0, new_samples.len);
        self.audio_data = new_buffer;

        // Update num_samples
        let num_new_samples = new_samples.len _/ 4;
        self.num_samples = self.num_samples + num_new_samples;

        // Update magnitude_buckets
        for (let var i = 0; i < num_new_samples; i = i + 1) {
            let sample = new_samples.read_f32(i);
            let abs_sample = sample.abs();

            // Increment magnitude bucket
            let bucket_idx = (abs_sample * 100).floor().min(99);
            self.magnitude_buckets[bucket_idx] = self.magnitude_buckets[bucket_idx] + 1;
        }

        // Calculate 99th percentile magnitude for normalization (max_sample_range)
        let target_samples = self.num_samples * 0.99;
        let var cumulative_samples = 0;
        let var calculated_max_sample_range = 0.0;
        for (let var i = 0; i < 100; ++i) {
            cumulative_samples = cumulative_samples + self.magnitude_buckets[i];
            if (cumulative_samples >= target_samples) {
                calculated_max_sample_range = (i + 1).to_f() / 100.0;
                break;
            }
        }

        // Fallback if no samples or all samples are very small
        if (calculated_max_sample_range == 0.0) {
            self.max_sample_range = 0.01; // A small default to avoid division by zero
        } else {
            self.max_sample_range = calculated_max_sample_range * 1.20;
        }
    }

    select(self, start_norm, end_norm) {
        // If no selection, reset to nil
        if (start_norm == nil || end_norm == nil) {
            self.s_idx = nil;
            self.e_idx = nil;
            return;
        }

        // Convert normalized coordinates to sample indices
        let s_idx_raw = (start_norm * self.num_samples.to_f()).floor();
        let e_idx_raw = (end_norm * self.num_samples.to_f()).floor();

        // Ensure indices are within bounds and correctly ordered
        self.s_idx = s_idx_raw.min(e_idx_raw).max(0).min(self.num_samples);
        self.e_idx = s_idx_raw.max(e_idx_raw).max(0).min(self.num_samples);
    }

    get_selection(self) {
        if (self.s_idx == nil || self.e_idx == nil) {
            return ByteArray.with_size(0);
        }

        let start_byte = self.s_idx * 4;
        let end_byte = self.e_idx * 4;
        let selection_size = end_byte - start_byte;

        let selection_data = ByteArray.with_size(selection_size);
        selection_data.memcpy(0, self.audio_data, start_byte, selection_size);

        return selection_data;
    }

    // Delete the current selection
    delete_sel(self) {
        if (self.s_idx == nil || self.e_idx == nil) {
            return;
        }

        assert(self.s_idx instanceof Int64);
        assert(self.e_idx instanceof Int64);
        let start_byte = self.s_idx * 4;
        let end_byte = self.e_idx * 4;

        let new_size = self.audio_data.len - (end_byte - start_byte);
        let new_buffer = ByteArray.with_size(new_size);

        // Copy the part before the selection
        new_buffer.memcpy(0, self.audio_data, 0, start_byte);

        // Copy the part after the selection
        new_buffer.memcpy(start_byte, self.audio_data, end_byte, self.audio_data.len - end_byte);

        self.audio_data = new_buffer;
        self.num_samples = new_size _/ 4;

        // Clear the selection
        self.select(nil, nil);
    }

    redraw(self, frame_buffer) {
        // Clear the buffer
        frame_buffer.zero_fill();

        if (self.num_samples == 0 || self.max_sample_range == 0.0) {
            return;
        }

        // Draw selection highlight first
        if (self.s_idx != nil && self.e_idx != nil) {
            // Convert sample indices to pixel coordinates for drawing
            let x1_pixel = (self.s_idx.to_f() / self.num_samples.to_f() * self.width.to_f()).floor();
            let x2_pixel = (self.e_idx.to_f() / self.num_samples.to_f() * self.width.to_f()).floor();

            let draw_x1 = x1_pixel.min(x2_pixel);
            let draw_x2 = x1_pixel.max(x2_pixel);
            let highlight_width = draw_x2 - draw_x1 + 1;

            if (highlight_width > 0) {
                draw_rect(frame_buffer, draw_x1, 0, highlight_width, self.height, SELECTION_COLOR);
            }
        }

        // For each column of the frame buffer
        for (let var i = 0; i < self.width; ++i)
        {
            let samples_per_col = (self.num_samples / self.width).max(1.0).min(200.0).floor();
            let start_idx = ((i / (self.width - 1)) * (self.num_samples - 1)).floor();
            let end_idx = (start_idx + samples_per_col).min(self.num_samples);

            // Determine the max sample value for this column
            let var max_sample = 0.0;
            for (let var k = start_idx; k < end_idx; ++k)
                max_sample = max_sample.max(self.audio_data.read_f32(k));

            // Compute the Y coordinate in the frame buffer for this sample
            let norm_v = (max_sample / self.max_sample_range).min(1.0).max(-1.0);
            let pos_v = ((1.0 + norm_v) / 2.0).min(1.0);
            let j = (pos_v * (self.height - 1)).floor();

            let mid_y = self.height _/ 2;
            let end_y = (j - mid_y).abs();
            for (let var k = mid_y - end_y; k < mid_y + end_y; ++k) {
                frame_buffer.write_u32(k * self.width + i, self.color);
            }
        }
    }
}

// --- Main Program ---
let frame_buffer = ByteArray.with_size(WIDTH * HEIGHT * 4);
let window = $window_create(WIDTH, HEIGHT, "Audio Recorder", 0);
let audio_in = $audio_open_input(SAMPLE_RATE, NUM_CHANNELS);
let wave_plot = WavePlot(WIDTH, HEIGHT, BLUE);
let var recording = false;

// Variables for mouse selection
let var is_dragging = false;
let var drag_start_x = nil;
let var drag_end_x = nil;

$println("Press SPACE to record audio, click and drag to select samples");

loop {
    // --- Event Handling ---
    let msg = $actor_poll();

    if (msg instanceof UIEvent) {
        if (msg.kind == 'CLOSE_WINDOW' || (msg.kind == 'KEY_DOWN' && msg.key == 'ESCAPE')) {
            break;
        }

        if (msg.kind == 'KEY_DOWN' && (msg.key == 'DELETE' || msg.key == 'BACKSPACE')) {
            wave_plot.delete_sel();
        }

        if (msg.kind == 'KEY_DOWN' && msg.key == 'SPACE') {
            recording = !recording;
            if (recording) {
                $println("Recording started...");
                wave_plot.clear_samples();
                wave_plot.select(nil, nil); // Clear selection on new recording
            } else {
                $println("Recording stopped.");
            }
        }

        if (msg.kind == 'MOUSE_DOWN') {
            is_dragging = true;
            drag_start_x = msg.x;
            drag_end_x = msg.x; // Start with a single point selection

            // Calculate normalized coordinates and pass to WavePlot
            let norm_start = drag_start_x.to_f() / wave_plot.width.to_f();
            let norm_end = drag_end_x.to_f() / wave_plot.width.to_f();
            wave_plot.select(norm_start, norm_end);
        }

        if (msg.kind == 'MOUSE_MOVE') {
            if (is_dragging) {
                drag_end_x = msg.x;

                // Calculate normalized coordinates and pass to WavePlot
                let norm_start = drag_start_x.to_f() / wave_plot.width.to_f();
                let norm_end = drag_end_x.to_f() / wave_plot.width.to_f();
                wave_plot.select(norm_start, norm_end);
            }
        }

        if (msg.kind == 'MOUSE_UP') {
            is_dragging = false;

            // Calculate normalized coordinates and pass to WavePlot
            let norm_start = drag_start_x.to_f() / wave_plot.width.to_f();
            let norm_end = drag_end_x.to_f() / wave_plot.width.to_f();
            wave_plot.select(norm_start, norm_end);
            $println("Selected samples: [" + wave_plot.s_idx.to_s() + ", " + wave_plot.e_idx.to_s() + "]");
        }
    }

    // Block and read a chunk of audio data
    let chunk = ByteArray.with_size(1024 * 4);
    $audio_read_samples(audio_in, 1024, chunk, 0);

    if (recording) {
        wave_plot.append_samples(chunk);
    }

    // --- Drawing ---
    wave_plot.redraw(frame_buffer);
    $window_draw_frame(window, frame_buffer);
}
