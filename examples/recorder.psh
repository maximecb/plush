let WIDTH = 800;
let HEIGHT = 600;

// Helper function to convert RGB values to a 32-bit color
fun rgb32(r, g, b) {
    return 0xFF_00_00_00 | (r << 16) | (g << 8) | b;
}

let BLACK = rgb32(0, 0, 0);
let BLUE = rgb32(50, 100, 255);
let WHITE = rgb32(255, 255, 255);

// --- Audio State ---
let SAMPLE_RATE = 44100;
let NUM_CHANNELS = 1;
let var recording = false;
let var audio_data = ByteArray.with_size(0);

// --- Main Program ---
let frame_buffer = ByteArray.with_size(WIDTH * HEIGHT * 4);
let window = $window_create(WIDTH, HEIGHT, "Audio Recorder", 0);
let audio_in = $audio_open_input(SAMPLE_RATE, NUM_CHANNELS);

fun draw_waveform(frame_buffer, data) {
    // Clear the buffer
    frame_buffer.zero_fill();

    let num_samples = data.len _/ 4;
    if (num_samples == 0) {
        return;
    }

    // Find the maximum absolute sample value
    let var max_abs_sample = 0.0;
    for (let var i = 0; i < num_samples; i = i + 1) {
        let sample = data.read_f32(i);
        if (sample.abs() > max_abs_sample) {
            max_abs_sample = sample.abs();
        }
    }
    max_abs_sample = max_abs_sample.min(1.0);

    // For each column of the frame buffer
    for (let var i = 0; i < WIDTH; ++i)
    {
        let samples_per_col = (num_samples / WIDTH).max(1.0).min(200.0).floor();
        let start_idx = ((i / (WIDTH - 1)) * (num_samples - 1)).floor();
        let end_idx = (start_idx + samples_per_col).min(num_samples);

        // Determine the max sample value for this column
        let var max_sample = 0.0;
        for (let var i = start_idx; i < end_idx; ++i)
            max_sample = max_sample.max(data.read_f32(i));

        // Compute the Y coordinate in the frame buffer for this sample
        let norm_v = (max_sample / max_abs_sample).min(1.0).max(-1.0);
        let pos_v = ((1.0 + norm_v) / 2.0).min(1.0);
        let j = (pos_v * (HEIGHT - 1)).floor();

        let mid_y = HEIGHT _/ 2;
        let end_y = (j - mid_y).abs();
        for (let var k = mid_y - end_y; k < mid_y + end_y; ++k) {
            frame_buffer.write_u32(k * WIDTH + i, BLUE);
        }
    }
}

$println("Press SPACE to record audio, press again to stop recording");

loop {
    // --- Event Handling ---
    let msg = $actor_poll();

    if (msg instanceof UIEvent) {
        if (msg.kind == 'CLOSE_WINDOW' || (msg.kind == 'KEY_DOWN' && msg.key == 'ESCAPE')) {
            break;
        }

        if (msg.kind == 'KEY_DOWN' && msg.key == 'SPACE') {
            recording = !recording;
            if (recording) {
                $println("Recording started...");
                audio_data = ByteArray.with_size(0);
            } else {
                $println("Recording stopped.");
            }
        }
    }

    // Block and read a chunk of audio data
    let chunk = ByteArray.with_size(1024 * 4);
    $audio_read_samples(audio_in, 1024, chunk, 0);

    if (recording) {
        let new_size = audio_data.len + chunk.len;
        let new_data = ByteArray.with_size(new_size);
        new_data.memcpy(0, audio_data, 0, audio_data.len);
        new_data.memcpy(audio_data.len, chunk, 0, chunk.len);
        audio_data = new_data;
    }

    // --- Drawing ---
    draw_waveform(frame_buffer, audio_data);
    $window_draw_frame(window, frame_buffer);
}
