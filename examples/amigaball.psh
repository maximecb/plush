let FRAME_WIDTH = 800;
let FRAME_HEIGHT = 600;

// --- Lighting ---
let LIGHT_DIRECTION = Vec3(0.5, 1.0, -0.5).normalize();
let AMBIENT_LIGHT = 0.4; // A small constant light

// --- 3D Math and Classes ---

let PI = 3.1415926535;

// Converts an angle from degrees to radians
fun deg2rad(deg) {
    return deg * PI / 180.0;
}

class Image {
    init(self, width, height) {
        self.width = width;
        self.height = height;
        self.bytes = ByteArray.with_size(4 * width * height);
    }

    fill(self, color) {
        self.bytes.fill_u32(0, self.width * self.height, color);
    }
}

class Vec3 {
    init(self, x, y, z) {
        self.x = x;
        self.y = y;
        self.z = z;
    }

    clone(self) {
        return Vec3(self.x, self.y, self.z);
    }

    add(self, other) {
        return Vec3(self.x + other.x, self.y + other.y, self.z + other.z);
    }

    sub(self, other) {
        return Vec3(self.x - other.x, self.y - other.y, self.z - other.z);
    }

    mul(self, scalar) {
        return Vec3(self.x * scalar, self.y * scalar, self.z * scalar);
    }

    dot(self, other) {
        return self.x * other.x + self.y * other.y + self.z * other.z;
    }

    cross(self, other) {
        return Vec3(
            self.y * other.z - self.z * other.y,
            self.z * other.x - self.x * other.z,
            self.x * other.y - self.y * other.x
        );
    }

    length_squared(self) {
        return self.dot(self);
    }

    normalize(self) {
        let len = self.length_squared().sqrt();
        if (len == 0.0) {
            return Vec3(0.0, 0.0, 0.0);
        }
        return Vec3(self.x / len, self.y / len, self.z / len);
    }
}

// Initializes a 4x4 matrix with zeros
// Matrices are row-major
fun mat4_init(m) {
    for (let var i = 0; i < 4; ++i) {
        let row = Array.with_size(4, 0.0);
        m.push(row);
    }
}

// Transform a 3D point using a 4x4 transformation matrix
fun mat4_mul_vec(i, m) {
    let o = Vec3(0, 0, 0);
    o.x   = i.x * m[0][0] + i.y * m[0][1] + i.z * m[0][2] + m[0][3];
    o.y   = i.x * m[1][0] + i.y * m[1][1] + i.z * m[1][2] + m[1][3];
    o.z   = i.x * m[2][0] + i.y * m[2][1] + i.z * m[2][2] + m[2][3];
    let w = i.x * m[3][0] + i.y * m[3][1] + i.z * m[3][2] + m[3][3];

    if (w != 0.0) {
        o.x = o.x / w;
        o.y = o.y / w;
        o.z = o.z / w;
    }

    return o;
}

// Transform a 3D vector (like a normal) using a 4x4 transformation matrix,
// ignoring translation and perspective components.
fun mat4_mul_vec_no_translation(i, m) {
    let o = Vec3(0, 0, 0);
    o.x   = i.x * m[0][0] + i.y * m[0][1] + i.z * m[0][2];
    o.y   = i.x * m[1][0] + i.y * m[1][1] + i.z * m[1][2];
    o.z   = i.x * m[2][0] + i.y * m[2][1] + i.z * m[2][2];
    return o.normalize(); // Re-normalize after transformation
}

// Multiplies two 4x4 matrices
fun mat4_mul(a, b) {
    let result = [];
    mat4_init(result);
    // For each row
    for (let var i = 0; i < 4; ++i) {
        // For each column
        for (let var j = 0; j < 4; ++j) {
            for (let var k = 0; k < 4; ++k) {
                result[i][j] = result[i][j] + a[i][k] * b[k][j];
            }
        }
    }
    return result;
}

// Matrix for a rotation around the X axis
fun mat4_rotx(theta)
{
    let result = [];
    mat4_init(result);

    let cost = theta.cos();
    let sint = theta.sin();

    // First row
    result[0][0] = 1.0;

    // Second
    result[1][1] = cost;
    result[1][2] = -sint;

    // Third row
    result[2][1] = sint;
    result[2][2] = cost;

    // Fourth row
    result[3][3] = 1.0;

    return result;
}

// Matrix for a rotation around the Y axis
fun mat4_roty(theta)
{
    let result = [];
    mat4_init(result);

    let cost = theta.cos();
    let sint = theta.sin();

    // First row
    result[0][0] = cost;
    result[0][2] = sint;

    // Second row
    result[1][1] = 1.0;

    // Third row
    result[2][0] = -sint;
    result[2][2] = cost;

    // Fourth row
    result[3][3] = 1.0;

    return result;
}

// Matrix for a translation
fun mat4_trans(x, y, z) {
    let m = [];
    mat4_init(m); // Initialize with zeros

    m[0][0] = 1.0;
    m[1][1] = 1.0;
    m[2][2] = 1.0;
    m[3][3] = 1.0;

    m[0][3] = x;
    m[1][3] = y;
    m[2][3] = z;

    return m;
}

// Matrix for a rotation around the Z axis
fun mat4_rotz(theta)
{
    let result = [];
    mat4_init(result);

    let cost = theta.cos();
    let sint = theta.sin();

    // First row
    result[0][0] = cost;
    result[0][1] = -sint;

    // Second row
    result[1][0] = sint;
    result[1][1] = cost;

    // Third row
    result[2][2] = 1.0;

    // Fourth row
    result[3][3] = 1.0;

    return result;
}

// Generate a perspective projection matrix identical to that
// produced by the gluPerspective() function.
// This is used to project coordinates from eye space into clip space.
// We follow OpenGL conventions.
//
// aspect = screen_width / screen_height
// fovy is in radians
//
// +Y points up,
// +X points to the right,
// -Z points into the screen.
//
// Points are projected such that X/Y are in [-1, 1]
// Z values between [near, far] get projected into [-1, 1]
// Points behind the near plane should be discarded (clipped) ahead of time.
//
fun perspective(fovy_rad, aspect, near, far) {
    let m = [];
    mat4_init(m);

    let f = 1.0 / (fovy_rad / 2.0).tan();
    let nf = 1.0 / (near - far);

    m[0][0] = f / aspect;
    m[0][1] = 0.0;
    m[0][2] = 0.0;
    m[0][3] = 0.0;

    m[1][0] = 0.0;
    m[1][1] = f;
    m[1][2] = 0.0;
    m[1][3] = 0.0;

    m[2][0] = 0.0;
    m[2][1] = 0.0;
    m[2][2] = (far + near) * nf;
    m[2][3] = 2.0 * far * near * nf;

    m[3][0] = 0.0;
    m[3][1] = 0.0;
    m[3][2] = -1.0;
    m[3][3] = 0.0;

    return m;
}

// Creates a view matrix that looks at a target from a given position
fun lookat(eye, target, up) {
    let forward = target.sub(eye).normalize();
    let right = forward.cross(up).normalize();
    let new_up = right.cross(forward);

    let m = [];
    mat4_init(m);

    m[0][0] = right.x;
    m[0][1] = right.y;
    m[0][2] = right.z;
    m[0][3] = -right.dot(eye);

    m[1][0] = new_up.x;
    m[1][1] = new_up.y;
    m[1][2] = new_up.z;
    m[1][3] = -new_up.dot(eye);

    m[2][0] = -forward.x;
    m[2][1] = -forward.y;
    m[2][2] = -forward.z;
    m[2][3] = forward.dot(eye);

    m[3][0] = 0.0;
    m[3][1] = 0.0;
    m[3][2] = 0.0;
    m[3][3] = 1.0;

    return m;
}

// Represents a 3D camera
class Camera {
    // Initializes the camera
    init(self, pos, target, fov_x, near, far) {
        self.pos = pos;
        self.target = target;
        self.fov_x = fov_x;
        self.near = near;
        self.far = far;
    }

    // Calculates the view matrix for the camera
    view_matrix(self) {
        let up = Vec3(0.0, 1.0, 0.0);
        return lookat(self.pos, self.target, up);
    }

    // Calculates the projection matrix for the camera
    projection_matrix(self, aspect) {
        let fov_x_rad = deg2rad(self.fov_x);
        let fov_y_rad = 2 * ((fov_x_rad / 2.0).tan() / aspect).atan();
        return perspective(fov_y_rad, aspect, self.near, self.far);
    }
}

// --- Triangle Rasterization ---

// This function expects the coordinates to be floats such that
// x is in [0, FRAME_WIDTH] and +x points right
// y is in [0, FRAME_HEIGHT] and +y points down
fun rasterize_triangle(v0, v1, v2, color, image) {
    let var p0 = v0;
    let var p1 = v1;
    let var p2 = v2;
    if (p0.y > p1.y) { let tmp = p0; p0 = p1; p1 = tmp; }
    if (p0.y > p2.y) { let tmp = p0; p0 = p2; p2 = tmp; }
    if (p1.y > p2.y) { let tmp = p1; p1 = p2; p2 = tmp; }

    let y0 = p0.y.floor();
    let y1 = p1.y.floor();
    let y2 = p2.y.floor();

    if (y0 == y2) return;

    let x0 = p0.x;
    let x1 = p1.x;
    let x2 = p2.x;

    let var inv_slope1 = 0.0;
    if (p1.y > p0.y) inv_slope1 = (p1.x - p0.x) / (p1.y - p0.y);

    let var inv_slope2 = 0.0;
    if (p2.y > p0.y) inv_slope2 = (p2.x - p0.x) / (p2.y - p0.y);

    let start_scanline_y_top = y0.max(0);
    let end_scanline_y_top = y1.min(FRAME_HEIGHT);

    if (start_scanline_y_top < end_scanline_y_top) {
        let var cur_x1 = x0 + (start_scanline_y_top + 1 - p0.y) * inv_slope1;
        let var cur_x2 = x0 + (start_scanline_y_top + 1 - p0.y) * inv_slope2;

        for (let var scanline_y = start_scanline_y_top; scanline_y < end_scanline_y_top; ++scanline_y) {
            let start_x = cur_x1.min(cur_x2).floor().max(0);
            let end_x = cur_x1.max(cur_x2).floor().min(FRAME_WIDTH);
            if (start_x < end_x) {
                image.bytes.fill_u32(scanline_y * FRAME_WIDTH + start_x, end_x - start_x, color);
            }
            cur_x1 = cur_x1 + inv_slope1;
            cur_x2 = cur_x2 + inv_slope2;
        }
    }

    let var inv_slope3 = 0.0;
    if (p2.y > p1.y) inv_slope3 = (p2.x - p1.x) / (p2.y - p1.y);

    let start_scanline_y_bot = y1.max(0);
    let end_scanline_y_bot = y2.min(FRAME_HEIGHT);

    if (start_scanline_y_bot < end_scanline_y_bot) {
        let var cur_x1 = x1 + (start_scanline_y_bot + 1 - p1.y) * inv_slope3;
        let var cur_x2 = x0 + (start_scanline_y_bot + 1 - p0.y) * inv_slope2;

        for (let var scanline_y = start_scanline_y_bot; scanline_y < end_scanline_y_bot; ++scanline_y) {
            let start_x = cur_x1.min(cur_x2).floor().max(0);
            let end_x = cur_x1.max(cur_x2).floor().min(FRAME_WIDTH);
            if (start_x < end_x) {
                image.bytes.fill_u32(scanline_y * FRAME_WIDTH + start_x, end_x - start_x, color);
            }
            cur_x1 = cur_x1 + inv_slope3;
            cur_x2 = cur_x2 + inv_slope2;
        }
    }
}

fun rasterize_line(v0, v1, color, image) {
    let var x0 = v0.x.floor();
    let var y0 = v0.y.floor();
    let var x1 = v1.x.floor();
    let var y1 = v1.y.floor();

    let dx = (x1 - x0).abs();
    let dy = -(y1 - y0).abs();

    let var sx = 1;
    if (x0 > x1) {
        sx = -1;
    }

    let var sy = 1;
    if (y0 > y1) {
        sy = -1;
    }

    let var err = dx + dy;

    loop {
        if (x0 >= 0 && x0 < FRAME_WIDTH && y0 >= 0 && y0 < FRAME_HEIGHT) {
            image.bytes.set_u32(y0 * FRAME_WIDTH + x0, color);
        }

        if (x0 == x1 && y0 == y1) {
            break;
        }

        let e2 = 2 * err;
        if (e2 >= dy) {
            err = err + dy;
            x0 = x0 + sx;
        }
        if (e2 <= dx) {
            err = err + dx;
            y0 = y0 + sy;
        }
    }
}

// --- Procedural Data Generation ---

let var lcg_seed = 1;
fun rand_init(seed) { lcg_seed = seed & 0x7FFFFFFF; }
fun rand_float(min_val, max_val) {
    lcg_seed = (lcg_seed * 1103515245 + 12345) & 0x7FFFFFFF;
    let val = lcg_seed.to_f() / 0x7FFFFFFF.to_f();
    return min_val + val * (max_val - min_val);
}

class RenderData {
    init(self) {
        self.vertices = [];
        self.indices = [];
        self.colors = [];
        self.normals = []; // New: Store normals for each triangle
    }

    transform(self, mat) {
        let new_render_data = RenderData();
        new_render_data.indices = self.indices;
        new_render_data.colors = self.colors;

        for (let var i = 0; i < self.vertices.len; ++i) {
            let v = mat4_mul_vec(self.vertices[i], mat);
            new_render_data.vertices.push(v);
        }

        // Transform normals as well, but without translation or perspective division
        for (let var i = 0; i < self.normals.len; ++i) {
            let n = mat4_mul_vec_no_translation(self.normals[i], mat);
            new_render_data.normals.push(n);
        }

        return new_render_data;
    }

    to_screen(self) {
        for (let var i = 0; i < self.vertices.len; ++i) {
            let v = self.vertices[i];
            // We need to invert Y to match screen coordinates
            v.x = (v.x + 1) * 0.5 * FRAME_WIDTH;
            v.y = (1 - v.y) * 0.5 * FRAME_HEIGHT;
        }

        return self;
    }

    append(self, other) {
        let vertex_offset = self.vertices.len;

        // Append vertices using Array.append
        self.vertices.append(other.vertices);

        // Append indices with offset
        let num_other_verts = other.indices.len;
        for (let var i = 0; i < num_other_verts; ++i) {
            self.indices.push(other.indices[i] + vertex_offset);
        }

        // Append colors using Array.append
        self.colors.append(other.colors);

        // Append normals using Array.append
        self.normals.append(other.normals);
    }

    // Sort the triangles by depth using a bucket sort
    sort_triangles_bucket(self, num_bins) {
        let num_triangles = self.indices.len _/ 3;
        if (num_triangles == 0) {
            return;
        }

        // Calculate the depth of each triangle
        let depths = Array.with_size(num_triangles, 0.0);
        for (let var i = 0; i < num_triangles; ++i) {
            let v0 = self.vertices[self.indices[i*3]];
            let v1 = self.vertices[self.indices[i*3+1]];
            let v2 = self.vertices[self.indices[i*3+2]];
            depths[i] = v0.z.max(v1.z).max(v2.z);
        }

        // Find the min and max depth
        let var min_depth = depths[0];
        let var max_depth = depths[0];
        for (let var i = 1; i < num_triangles; ++i) {
            if (depths[i] < min_depth) {
                min_depth = depths[i];
            }
            if (depths[i] > max_depth) {
                max_depth = depths[i];
            }
        }

        let depth_range = max_depth - min_depth;

        // Create buckets
        let buckets = [];
        for (let var i = 0; i < num_bins; ++i) {
            buckets.push([]);
        }

        // Distribute triangles into buckets
        for (let var i = 0; i < num_triangles; ++i) {
            let var bin_idx = ((depths[i] - min_depth) / depth_range * (num_bins - 1)).trunc();
            if (bin_idx < 0) {
                bin_idx = 0;
            }
            if (bin_idx >= num_bins) {
                bin_idx = num_bins - 1;
            }
            buckets[bin_idx].push(i);
        }

        // Create an array to store the final order of triangles
        let triangle_order = [];

        // Sort each bucket and concatenate the results
        // The buckets should be processed from far to near for back-to-front rendering
        for (let var i = num_bins - 1; i >= 0; --i) {
            let bucket = buckets[i];
            let bucket_len = bucket.len;
            if (bucket_len == 0) {
                continue;
            }

            // Using insertion sort for simplicity within buckets (sorts back to front)
            for (let var j = 1; j < bucket_len; ++j) {
                let key_idx = bucket[j];
                let key_depth = depths[key_idx];
                let var k = j - 1;
                while (k >= 0 && depths[bucket[k]] < key_depth) {
                    bucket[k+1] = bucket[k];
                    k = k - 1;
                }
                bucket[k+1] = key_idx;
            }

            for (let var j = 0; j < bucket_len; ++j) {
                triangle_order.push(bucket[j]);
            }
        }

        // Rearrange self.indices, self.colors, and self.normals based on the sorted triangle_order
        let new_indices = Array.with_size(num_triangles * 3, 0);
        let new_colors = Array.with_size(num_triangles, 0);
        let new_normals = Array.with_size(num_triangles, 0);

        for (let var k = 0; k < num_triangles; ++k) {
            let original_triangle_idx = triangle_order[k];
            new_colors[k] = self.colors[original_triangle_idx];
            new_indices[k*3] = self.indices[original_triangle_idx*3];
            new_indices[k*3+1] = self.indices[original_triangle_idx*3+1];
            new_indices[k*3+2] = self.indices[original_triangle_idx*3+2];
            new_normals[k] = self.normals[original_triangle_idx];
        }
        self.indices = new_indices;
        self.colors = new_colors;
        self.normals = new_normals;
    }
}

fun generate_amiga_ball(radius, stacks, sectors) {
    let data = RenderData();

    let base_idx = data.vertices.len;

    // Generate vertices
    for (let var i = 0; i <= stacks; ++i) {
        let phi = i * PI / stacks;
        let sin_phi = phi.sin();
        let cos_phi = phi.cos();

        for (let var j = 0; j <= sectors; ++j) {
            let theta = j * 2 * PI / sectors;
            let sin_theta = theta.sin();
            let cos_theta = theta.cos();

            let x = radius * cos_theta * sin_phi;
            let y = radius * cos_phi;
            let z = radius * sin_theta * sin_phi;

            data.vertices.push(Vec3(x, y, z));
        }
    }

    let red = 0xFF_FF_00_00;
    let white = 0xFF_FF_FF_FF;

    // Generate indices, colors, and normals for triangles
    for (let var i = 0; i < stacks; ++i) {
        for (let var j = 0; j < sectors; ++j) {
            let first = base_idx + i * (sectors + 1) + j;
            let second = base_idx + (i + 1) * (sectors + 1) + j;

            let var color = nil;
            if ((i _/ 2 % 2) != (j _/ 4 % 2)) {
                color = red;
            } else {
                color = white;
            }

            // Triangle 1
            data.indices.push(first);
            data.indices.push(first + 1);
            data.indices.push(second);
            data.colors.push(color);

            let v0 = data.vertices[first];
            let v1 = data.vertices[second];
            let v2 = data.vertices[first + 1];
            let n0 = v0.normalize();
            let n1 = v1.normalize();
            let n2 = v2.normalize();
            data.normals.push(n0.add(n1).add(n2).normalize());

            // Triangle 2
            data.indices.push(second);
            data.indices.push(first + 1);
            data.indices.push(second + 1);
            data.colors.push(color);

            let v3 = data.vertices[second + 1];
            let n3 = v3.normalize();
            data.normals.push(n1.add(n3).add(n2).normalize());
        }
    }

    return data;
}

// Generate a grid along the XZ axes
fun generate_grid(size, spacing) {
    let data = RenderData();

    // Generate all unique vertices for the grid
    for (let var j = 0; j <= size; ++j) {
        for (let var i = 0; i <= size; ++i) {
            let x = i * spacing;
            let z = j * spacing;
            data.vertices.push(Vec3(x, 0, z));
        }
    }

    let num_verts_per_row = size + 1;

    // Indices for lines along Z-axis
    for (let var i = 0; i <= size; ++i) {
        for (let var j = 0; j < size; ++j) {
            let idx0 = j * num_verts_per_row + i;
            let idx1 = (j + 1) * num_verts_per_row + i;
            data.indices.push(idx0);
            data.indices.push(idx1);
        }
    }

    // Indices for lines along X-axis
    for (let var j = 0; j <= size; ++j) {
        for (let var i = 0; i < size; ++i) {
            let idx0 = j * num_verts_per_row + i;
            let idx1 = j * num_verts_per_row + i + 1;
            data.indices.push(idx0);
            data.indices.push(idx1);
        }
    }

    return data;
}

let window = $window_create(FRAME_WIDTH, FRAME_HEIGHT, "Amiga Bouncing Ball", 0);
let image = Image(FRAME_WIDTH, FRAME_HEIGHT);

let var ball_data = generate_amiga_ball(0.5, 16, 32);
let grid_data = generate_grid(16, 0.2);
let wall1 = grid_data.transform(mat4_rotx(-PI/2));
let wall2 = grid_data.transform(mat4_rotz(-PI/2));
grid_data.append(wall1);
//grid_data.append(wall2);

// Camera setup
let aspect = FRAME_WIDTH.to_f() / FRAME_HEIGHT.to_f();
let camera = Camera(
    Vec3(1.6, 2, 4.5),
    Vec3(1.6, 1, 1.6),
    70.0,   // fov
    1.0,    // near
    30.0    // far
);

let mat_proj = camera.projection_matrix(aspect);

let var ball_pos = Vec3(1.6, 2, 1.6);
let var ball_vel = Vec3(0.03, 0.0, 0.01);
let var ball_rot = Vec3(0, 0, 0);
let var ball_rot_vel = Vec3(0.01, 0.02, 0.03);

// Main animation loop
loop {
    // --- Event Handling ---
    let msg = $actor_poll();
    if (msg != nil && msg instanceof UIEvent) {
        if (msg.kind == 'CLOSE_WINDOW' || (msg.kind == 'KEY_DOWN' && msg.key == 'ESCAPE')) {
            break;
        }
    }

    image.fill(0xFF_25_25_25);

    // --- Animation Update ---

    // Apply gravity
    ball_vel.y = ball_vel.y - 0.005;

    // Update ball position
    ball_pos = ball_pos.add(ball_vel);

    // Update ball rotation
    ball_rot = ball_rot.add(ball_rot_vel);

    let ball_radius = 0.5;
    let grid_size = 16 * 0.2;

    // Bounce off the floor
    if (ball_pos.y < ball_radius) {
        let overshoot = ball_radius - ball_pos.y;
        ball_pos.y = ball_radius + overshoot;
        ball_vel.y = -ball_vel.y;
    }

    // Bounce off the walls
    if (ball_pos.x < ball_radius || ball_pos.x > grid_size - ball_radius) {
        ball_vel.x = -ball_vel.x;
    }
    if (ball_pos.z < ball_radius || ball_pos.z > grid_size - ball_radius) {
        ball_vel.z = -ball_vel.z;
    }

    // --- Matrix Calculation ---
    let mat_view = camera.view_matrix();

    // Create the ball's model matrix
    let mat_rot_x = mat4_rotx(ball_rot.x);
    let mat_rot_y = mat4_roty(ball_rot.y);
    let mat_rot_z = mat4_rotz(ball_rot.z);
    let mat_rot = mat4_mul(mat4_mul(mat_rot_x, mat_rot_y), mat_rot_z);
    let mat_trans = mat4_trans(ball_pos.x, ball_pos.y, ball_pos.z);
    let mat_model_ball = mat4_mul(mat_trans, mat_rot);

    // Transformation chain: model -> view -> projection
    let mat_mvp_ball = mat4_mul(mat_proj, mat4_mul(mat_view, mat_model_ball));
    let mat_mvp_grid = mat4_mul(mat_proj, mat_view);

    // Render scene
    let transform_start = $time_current_ms();
    let transformed_ball_data = ball_data.transform(mat_mvp_ball).to_screen();
    let transformed_grid_data = grid_data.transform(mat_mvp_grid).to_screen();
    let transform_time = $time_current_ms() - transform_start;

    let sort_start = $time_current_ms();
    transformed_ball_data.sort_triangles_bucket(4096);
    let sort_time = $time_current_ms() - sort_start;

    let raster_start = $time_current_ms();

    // Draw the grid
    let grid_color = 0xFF_F0_00_F0; // Purple color for the grid
    for (let var i = 0; i < transformed_grid_data.indices.len; i = i + 2) {
        let v0 = transformed_grid_data.vertices[transformed_grid_data.indices[i]];
        let v1 = transformed_grid_data.vertices[transformed_grid_data.indices[i+1]];
        rasterize_line(v0, v1, grid_color, image);
    }

    // Draw the sphere
    for (let var i = 0; i < transformed_ball_data.indices.len; i = i + 3) {
        let v0 = transformed_ball_data.vertices[transformed_ball_data.indices[i]];
        let v1 = transformed_ball_data.vertices[transformed_ball_data.indices[i+1]];
        let v2 = transformed_ball_data.vertices[transformed_ball_data.indices[i+2]];

        // Backface culling: check winding order in screen space.
        if ((v1.x - v0.x) * (v2.y - v0.y) - (v2.x - v0.x) * (v1.y - v0.y) < 0) {
            let base_color = transformed_ball_data.colors[i _/ 3];
            rasterize_triangle(v0, v1, v2, base_color, image);
        }
    }

    let raster_time = $time_current_ms() - raster_start;

    $println(
        "triangles: " + transformed_ball_data.colors.len.to_s() +
        ", transform: " + transform_time.to_s() +
        "ms, sort: " + sort_time.to_s() +
        "ms, rasterize: " + raster_time.to_s() + "ms"
    );

    $window_draw_frame(window, image.bytes);

    // --- Frame rate limiting ---
    $actor_sleep(20);
}
