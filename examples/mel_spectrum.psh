// Constants
let SAMPLE_RATE = 44100;
let NUM_CHANNELS = 1;
let WINDOW_WIDTH = 800;
let WINDOW_HEIGHT = 600;
let FFT_SIZE = 1024; // Must be a power of 2
let NUM_FREQUENCY_BANDS = 32;
let PI = 3.141592653589793;
let DECAY_FACTOR = 0.94; // For gradual decay
let BAR_HORIZONTAL_GAP = 2; // Horizontal gap between bars

let MIN_FREQ = 300.0;
let MAX_FREQ = 3500.0;

let AUDIO_FRAME_TIME = 1000 * (FFT_SIZE / SAMPLE_RATE);

// Helper function to convert RGB values to a 32-bit color
fun rgb32(r, g, b) {
    // The alpha channel is set to 0xFF (fully opaque)
    return 0xFF000000 | (r << 16) | (g << 8) | b;
}

// Function to perform in-place iterative FFT (Cooley-Tukey)
fun fft(real_parts, imag_parts, inverse) {
    let n = real_parts.len _/ 4; // Number of complex samples (each float32 is 4 bytes)
    if (n == 0) {
        return;
    }

    // Bit-reversal permutation
    let var i = 0;
    let var j = 0;
    while (i < n) {
        if (j > i) {
            // Swap real parts
            let temp_re = real_parts.read_f32(i);
            real_parts.write_f32(i, real_parts.read_f32(j));
            real_parts.write_f32(j, temp_re);

            // Swap imaginary parts
            let temp_im = imag_parts.read_f32(i);
            imag_parts.write_f32(i, imag_parts.read_f32(j));
            imag_parts.write_f32(j, temp_im);
        }
        let var m = n _/ 2;
        while (m >= 1 && j >= m) {
            j = j - m;
            m = m _/ 2;
        }
        j = j + m;
        i = i + 1;
    }

    // Cooley-Tukey butterfly operations
    let var len = 2;
    while (len <= n) {
        let var ang = 2.0 * PI / len;
        if (inverse) {
            ang = -ang;
        }
        let wlen_re = ang.cos();
        let wlen_im = ang.sin();

        let var i = 0;
        while (i < n) {
            let var w_re = 1.0;
            let var w_im = 0.0;
            let var j = 0;
            while (j < len _/ 2) {
                let u_re = real_parts.read_f32(i + j);
                let u_im = imag_parts.read_f32(i + j);

                let x_half_re = real_parts.read_f32(i + j + len _/ 2);
                let x_half_im = imag_parts.read_f32(i + j + len _/ 2);
                let v_re = x_half_re * w_re - x_half_im * w_im;
                let v_im = x_half_re * w_im + x_half_im * w_re;

                real_parts.write_f32(i + j, u_re + v_re);
                imag_parts.write_f32(i + j, u_im + v_im);

                real_parts.write_f32(i + j + len _/ 2, u_re - v_re);
                imag_parts.write_f32(i + j + len _/ 2, u_im - v_im);

                let next_w_re = w_re * wlen_re - w_im * wlen_im;
                let next_w_im = w_re * wlen_im + w_im * wlen_re;
                w_re = next_w_re;
                w_im = next_w_im;

                j = j + 1;
            }
            i = i + len;
        }
        len = len * 2;
    }

    if (inverse) {
        for (let var k = 0; k < n; ++k) {
            real_parts.write_f32(k, real_parts.read_f32(k) / n);
            imag_parts.write_f32(k, imag_parts.read_f32(k) / n);
        }
    }
}

// Function to apply a Hanning window to a buffer
fun hanning_window(buffer) {
    let n = buffer.len _/ 4;
    for (let var i = 0; i < n; ++i) {
        let multiplier = 0.5 * (1.0 - (2.0 * PI * i / (n - 1)).cos());
        buffer.write_f32(i, buffer.read_f32(i) * multiplier);
    }
}

fun mel_bins(real_parts, imag_parts, num_bins, min_freq, max_freq, fft_size, sample_rate) {
    // This function could be optimized by pre-calculating and caching the fft_bins array.
    let fft_bins = Array.with_size(num_bins + 2, 0);
    for (let var i = 0; i < fft_bins.len; ++i) {
        let freq = min_freq * (max_freq/min_freq).pow(i.to_f() / (num_bins + 1).to_f());
        fft_bins[i] = (freq * fft_size / sample_rate).floor();
    }

    let magnitudes = Array.with_size(num_bins, 0.0);
    for (let var band_idx = 0; band_idx < num_bins; ++band_idx) {
        let var band_magnitude = 0.0;
        let start_bin = fft_bins[band_idx];
        let center_bin = fft_bins[band_idx + 1];
        let end_bin = fft_bins[band_idx + 2];

        let max_bin = (fft_size / 2) - 1;
        if (start_bin > max_bin) continue;

        for (let var bin = start_bin; bin <= end_bin; ++bin) {
            if (bin > max_bin) break;

            let re = real_parts.read_f32(bin);
            let im = imag_parts.read_f32(bin);
            let magnitude = (re * re + im * im).sqrt();

            let var weight = 0.0;
            if (bin >= start_bin && bin <= center_bin) {
                if (center_bin - start_bin > 0) {
                    weight = (bin - start_bin).to_f() / (center_bin - start_bin);
                } else if (bin == center_bin) {
                    weight = 1.0;
                }
            } else if (bin > center_bin && bin <= end_bin) {
                if (end_bin - center_bin > 0) {
                    weight = (end_bin - bin).to_f() / (end_bin - center_bin);
                }
            }
            band_magnitude = band_magnitude + magnitude * weight;
        }
        magnitudes[band_idx] = band_magnitude;
    }

    return magnitudes;
}

fun main() {
    let window_id = $window_create(WINDOW_WIDTH, WINDOW_HEIGHT, "Mel Spectrum Analyzer", 0);
    let audio_input_device_id = $audio_open_input(SAMPLE_RATE, NUM_CHANNELS);

    let real_parts = ByteArray.with_size(FFT_SIZE * 4);
    let imag_parts = ByteArray.with_size(FFT_SIZE * 4);
    imag_parts.zero_fill();

    let band_heights = Array.with_size(NUM_FREQUENCY_BANDS, 0.0);
    let frame_buffer = ByteArray.with_size(WINDOW_WIDTH * WINDOW_HEIGHT * 4);

    let var running = true;
    while (running) {
        $audio_read_samples(audio_input_device_id, FFT_SIZE, real_parts, 0);

        let start_time = $time_current_ms();
        imag_parts.zero_fill();
        hanning_window(real_parts);
        fft(real_parts, imag_parts, false);
        let magnitudes = mel_bins(real_parts, imag_parts, NUM_FREQUENCY_BANDS, MIN_FREQ, MAX_FREQ, FFT_SIZE, SAMPLE_RATE);
        let end_time = $time_current_ms();
        $println("Audio analysis time: " + (end_time - start_time).to_s() + "ms (/" + AUDIO_FRAME_TIME.format_decimals(1) + "ms)");

        frame_buffer.zero_fill();
        let bar_width_total = WINDOW_WIDTH _/ NUM_FREQUENCY_BANDS;
        let bar_width_drawn = (bar_width_total - BAR_HORIZONTAL_GAP).max(1);
        let max_magnitude = 10.0;

        for (let var band_idx = 0; band_idx < NUM_FREQUENCY_BANDS; ++band_idx) {
            let band_magnitude = magnitudes[band_idx];
            let new_bar_height = (band_magnitude / max_magnitude * WINDOW_HEIGHT.to_f()).min(WINDOW_HEIGHT.to_f());

            if (new_bar_height > band_heights[band_idx]) {
                band_heights[band_idx] = new_bar_height;
            } else {
                band_heights[band_idx] = band_heights[band_idx] * DECAY_FACTOR;
            }

            let current_display_height = band_heights[band_idx];
            let x_draw = band_idx * bar_width_total + (BAR_HORIZONTAL_GAP _/ 2);
            let y_start_drawing = WINDOW_HEIGHT - current_display_height.trunc();

            let color = rgb32(255, 0, 0);

            let BAR_SEGMENT_HEIGHT = 5;
            let BAR_GAP_HEIGHT = 2;
            let total_segment_height = BAR_SEGMENT_HEIGHT + BAR_GAP_HEIGHT;

            for (let var segment_y = WINDOW_HEIGHT - total_segment_height; segment_y >= y_start_drawing; segment_y = segment_y - total_segment_height) {
                for (let var i = 0; i < bar_width_drawn; ++i) {
                    for (let var j = segment_y; j < segment_y + BAR_SEGMENT_HEIGHT; ++j) {
                        if (j >= y_start_drawing && j < WINDOW_HEIGHT) {
                            let pixel_idx = (j * WINDOW_WIDTH + (x_draw + i));
                            frame_buffer.write_u32(pixel_idx, color);
                        }
                    }
                }
            }
        }

        $window_draw_frame(window_id, frame_buffer);

        let event = $actor_poll();
        if (event instanceof UIEvent) {
            if (event.kind == "CLOSE_WINDOW" || event.key == "ESCAPE") {
                running = false;
            }
        }
    }

    $actor_sleep(500);
}

main();
