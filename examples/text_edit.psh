from ./image import Image, rgb, COLOR_WHITE, COLOR_C64_BLUE;
from ./monogram_font import Font;

let FRAME_WIDTH = 1000;
let FRAME_HEIGHT = 700;

let NUM_COLS = 70;
let NUM_ROWS = 29;

// Lines of text in the editor
let var lines = [[]];

// Cursor position and state
let var cursor_row = 0;
let var cursor_col = 0;
let var cursor_on = true;

// Top left corner position of the viewport
let var top_row = 0;
let var top_col = 0;

let frame_buffer = Image(FRAME_WIDTH, FRAME_HEIGHT);
let window = $window_create(FRAME_WIDTH, FRAME_HEIGHT, "Text Editor", 0);

let font = Font(2, COLOR_WHITE);

fun redraw()
{
    if (cursor_col >= top_col + NUM_COLS) {
        top_col = cursor_col - NUM_COLS + 1;
    }
    if (cursor_col < top_col) {
        top_col = cursor_col;
    }

    if (cursor_row >= top_row + NUM_ROWS) {
        top_row = cursor_row - NUM_ROWS + 1;
    }
    if (cursor_row < top_row) {
        top_row = cursor_row;
    }

    // Functions to compute x/y coordinates for a character
    fun char_x(col) { return 8 + col * font.char_w; }
    fun char_y(row) { return 2 + row * font.char_h; }

    frame_buffer.clear(COLOR_C64_BLUE);

    let start_time = $time_current_ms();

    // For each row to draw
    for (let var i = 0; i < NUM_ROWS; ++i)
    {
        if (top_row + i >= lines.len) {
            break;
        }

        // Get the current line for this row
        let line = lines[top_row + i];

        // For each column to draw
        for (let var j = 0; j < NUM_COLS; ++j)
        {
            if (top_col + j >= line.len) {
                break;
            }

            let ch = line[top_col + j];
            font.draw_char(frame_buffer, char_x(j), char_y(i), ch);
        }
    }

    if (cursor_on) {
        font.draw_char(
            frame_buffer,
            char_x(cursor_col - top_col),
            char_y(cursor_row - top_row),
            'ï¼¿'
        );
    }

    let end_time = $time_current_ms();
    let redraw_time = end_time - start_time;
    $println('Redraw time: ' + redraw_time.to_s() + 'ms');

    $window_draw_frame(window, frame_buffer.bytes);
}

fun blink_timer()
{
    let var cursor_state = false;

    loop {
        $actor_sleep(400);
        cursor_state = !cursor_state;
        $actor_send($actor_parent(), cursor_state? 'CURSOR_ON':'CURSOR_OFF');
    }
}

// Key down handler
fun key_down(key)
{
    if (key == 'LEFT') {
        if (cursor_col > 0) {
            --cursor_col;
        }

        redraw();
        return;
    }

    if (key == 'RIGHT') {
        if (cursor_col < lines[cursor_row].len) {
            ++cursor_col;
        }

        redraw();
        return;
    }

    if (key == 'DOWN') {
        if (cursor_row < lines.len) {
            ++cursor_row;
            let row_len = (cursor_row < lines.len)? lines[cursor_row].len:0;
            cursor_col = cursor_col.min(row_len);
        }

        redraw();
        return;
    }

    if (key == 'UP') {
        if (cursor_row > 0) {
            --cursor_row;
            let row_len = (cursor_row < lines.len)? lines[cursor_row].len:0;
            cursor_col = cursor_col.min(row_len);
        }

        redraw();
        return;
    }

    if (key == 'BACKSPACE') {
        if (cursor_col > 0) {
            --cursor_col;
            lines[cursor_row].remove(cursor_col);
        } else if (cursor_col == 0 && cursor_row > 0) {
            cursor_col = lines[cursor_row - 1].len;
            lines[cursor_row - 1].append(lines[cursor_row]);
            lines.remove(cursor_row);
            --cursor_row;
        }

        redraw();
        return;
    }

    if (key == 'RETURN') {
        let cur_line = lines[cursor_row];
        let new_line = [];

        for (let var i = cursor_col; i < cur_line.len; ++i)
            new_line.push(cur_line[i]);

        while (cur_line.len > cursor_col)
            cur_line.pop();

        ++cursor_row;
        cursor_col = 0;
        lines.insert(cursor_row, new_line);

        redraw();
        return;
    }
}

// Name of the file to open, nil if not set
let var file_name = $cmd_get_arg(1);
if (file_name == nil) {
    file_name = 'README.md';
}

if (file_name != nil) {
    let file_data = $read_file_utf8(file_name);
    $println(file_data.len);

    lines = [];
    let var line = [];

    for (let var i = 0; i < file_data.len; ++i)
    {
        let ch = file_data.char_at(i);
        if (ch == nil || ch == '\r') {
            continue;
        }

        if (ch == '\n') {
            lines.push(line);
            line = [];
            continue;
        }

        line.push(ch);
    }
}

// Draw a first frame, which will cause the window to appear
redraw();

// Spawn an actor to send us back cursor blinking events
$actor_spawn(blink_timer);

loop {
    let msg = $actor_recv();

    if (msg == 'CURSOR_ON') {
        cursor_on = true;
        redraw();
        continue;
    }

    if (msg == 'CURSOR_OFF') {
        cursor_on = false;
        redraw();
        continue;
    }

    if (msg.kind == 'CLOSE_WINDOW') {
        break;
    }

    if (msg.kind == 'KEY_DOWN') {
        key_down(msg.key);
        continue;
    }

    if (msg.kind == 'TEXT_INPUT') {
        for (let var i = 0; i < msg.text.len; ++i)
        {
            let ch = msg.text.char_at(i);
            if (ch == nil) {
                continue;
            }

            $println(ch);

            if (cursor_row < lines.len) {
                let line = lines[cursor_row];
                line.insert(cursor_col, ch);
                ++cursor_col;
            }
        }

        redraw();
        continue;
    }
}
