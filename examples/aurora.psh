// Mandelbrot Set Explorer II

// This example builds on mandelbrot.psh.
// Differences:
// - Uses a different palette with aurora borealis colors
// - Renders the set concurrently using actors
//
// Each actor is given a set of rows and calculates the
// corresponding array of colors, sending it back to the
// main thread/actor where they are $memcpy'd onto the
// final image.

let WIDTH = 640;
let HEIGHT = 480;

// The region of the complex plane to render
let RE_START = -2.0;
let RE_END = 1.0;
let IM_START = -1.125;
let IM_END = 1.125;

let MAX_ITER = 60;
let NTHREADS = 16;

// Helper function to convert RGB values to a 32-bit color
fun rgb32(r, g, b) {
    return 0xFF_00_00_00 | (r << 16) | (g << 8) | b;
}

// Create an aurora borealis color palette.
// Interpolate from (1, 239, 172) to (95, 42, 132) in
// only a few steps - MAX_ITER / 10 is empirical.
let palette = [];
for (let var i = 0; i < MAX_ITER _/ 10; ++i) {
    let t = i / ( MAX_ITER _/ 10);
    let r = (  1 + ( 95 -   1) * t).floor();
    let g = (239 + ( 42 - 239) * t).floor();
    let b = (172 + (132 - 172) * t).floor();
    palette.push(rgb32(r, g, b));
}

// Check if a point is in the Mandelbrot set in max_iter steps
fun fugue(c_re, c_im, max_iter) {
    let var z_re = 0.0;
    let var z_im = 0.0;
    let var iter = 0;

    while (z_re * z_re + z_im * z_im <= 4.0 && iter < max_iter) {
        let z_re_new = z_re * z_re - z_im * z_im + c_re;
        z_im = 2.0 * z_re * z_im + c_im;
        z_re = z_re_new;
        iter = iter + 1;
    }

    return iter;
}

// --- Pseudo-Random Number Generator (LCG) ---
// @see also: examples/random.psh
let var lcg_seed = 1;
fun rand_init(seed) {
    lcg_seed = seed & 0x7FFFFFFF;
}

fun rand_int(max_val) {
    lcg_seed = (lcg_seed * 1103515245 + 12345) & 0x7FFFFFFF;
    return lcg_seed % max_val;
}

// Every once in a while, generate a white dot
fun rand_star(color) {
    return rand_int(809) == 0 ? rgb32(255, 255, 255) : color;
}

// Colorize buffer points from..to
fun colorizer(from, to) {
    rand_init($actor_id() + $time_current_ms());
    let color_array = ByteArray.with_size(WIDTH*4*(to-from));
    let var idx = 0;
    for (let var y = from; y < to; ++y) {
        for (let var x = 0; x < WIDTH; ++x) {
            let c_re = RE_START + (x / WIDTH) * (RE_END - RE_START);
            let c_im = IM_START + (y / HEIGHT) * (IM_END - IM_START);

            let iter = fugue(c_re, c_im, MAX_ITER);

            // Set the pixel color based on the number of iterations
            let color = (iter == MAX_ITER) ? rgb32(5, 15, 50) : palette[iter % (MAX_ITER _/ 10)];
            color_array.set_u32(idx, rand_star(color));
            ++idx;
        }
    }
    $actor_send(0, [$actor_id(), color_array]);
}

// Color pixels in parallel
let start_time = $time_current_ms();

// Distribute rows and hand them to actors
let var to = 0;
let actor_boundaries = {};
for (let var i = 0; i < NTHREADS; ++i) {
    let from = to;
    to += (HEIGHT _/ NTHREADS + ((i < HEIGHT % NTHREADS) ? 1 : 0));
    let actor_id = $actor_spawn(|| colorizer(from, to));
    actor_boundaries[actor_id.to_s()] = from;
}

// Final image as a ByteArray
let frame_buffer = ByteArray.with_size(WIDTH * HEIGHT * 4);

// Main actor - loop until all actors are done
let var completed = 0;
loop {
    let msg = $actor_recv();
    let actor_id = msg[0].to_s();
    let colors = msg[1];

    let from = actor_boundaries[actor_id];
    frame_buffer.memcpy(from * WIDTH * 4, colors, 0, colors.len);

    if (++completed == NTHREADS) {
        break;
    }
}

// Print render time
let render_time = $time_current_ms() - start_time;
$println("Mandelbrot render time: " + render_time.to_s() + "ms");

// --- Window and Event Loop ---
let window = $window_create(WIDTH, HEIGHT, "Mandelbrot Set", 0);
$window_draw_frame(window, frame_buffer);

loop {
    let msg = $actor_recv();

    if (!(msg instanceof UIEvent)) {
        continue;
    }
    if (msg.kind == 'CLOSE_WINDOW' || (msg.kind == 'KEY_DOWN' && msg.key == 'ESCAPE')) {
        break;
    }
    $window_draw_frame(window, frame_buffer);
}

// well, this helps a bit in Vim...
// vim: set syn=cpp:
