// FFT Benchmark (Refactored for inlined operations and ByteArray)

// Function to perform in-place iterative FFT (Cooley-Tukey)
// Input: two ByteArray of float32 values, one for real parts and one for imaginary parts
// Output: the FFT of the input, in-place in the same ByteArrays
fun fft(real_parts, imag_parts, inverse) {
    let n = real_parts.len _/ 4; // Number of complex samples (each float32 is 4 bytes)
    if (n == 0) {
        return;
    }

    // Bit-reversal permutation
    let var i = 0;
    let var j = 0;
    while (i < n) {
        if (j > i) {
            // Swap real parts
            let temp_re = real_parts.read_f32(i);
            real_parts.write_f32(i, real_parts.read_f32(j));
            real_parts.write_f32(j, temp_re);

            // Swap imaginary parts
            let temp_im = imag_parts.read_f32(i);
            imag_parts.write_f32(i, imag_parts.read_f32(j));
            imag_parts.write_f32(j, temp_im);
        }
        let var m = n _/ 2;
        while (m >= 1 && j >= m) {
            j = j - m;
            m = m _/ 2;
        }
        j = j + m;
        i = i + 1;
    }

    // Cooley-Tukey butterfly operations
    let PI = 3.141592653589793;
    let var len = 2;
    while (len <= n) {
        let var ang = 2.0 * PI / len;
        if (inverse) {
            ang = -ang;
        }
        let wlen_re = ang.cos();
        let wlen_im = ang.sin();

        let var i = 0;
        while (i < n) {
            let var w_re = 1.0;
            let var w_im = 0.0;
            let var j = 0;
            while (j < len _/ 2) {
                let u_re = real_parts.read_f32(i + j);
                let u_im = imag_parts.read_f32(i + j);

                // v = x[i + j + len / 2] * w
                let x_half_re = real_parts.read_f32(i + j + len _/ 2);
                let x_half_im = imag_parts.read_f32(i + j + len _/ 2);
                let v_re = x_half_re * w_re - x_half_im * w_im;
                let v_im = x_half_re * w_im + x_half_im * w_re;

                // x[i + j] = u + v
                real_parts.write_f32(i + j, u_re + v_re);
                imag_parts.write_f32(i + j, u_im + v_im);

                // x[i + j + len / 2] = u - v
                real_parts.write_f32(i + j + len _/ 2, u_re - v_re);
                imag_parts.write_f32(i + j + len _/ 2, u_im - v_im);

                // w = w * wlen
                let next_w_re = w_re * wlen_re - w_im * wlen_im;
                let next_w_im = w_re * wlen_im + w_im * wlen_re;
                w_re = next_w_re;
                w_im = next_w_im;

                j = j + 1;
            }
            i = i + len;
        }
        len = len * 2;
    }

    // Apply 1/N factor for inverse FFT
    if (inverse) {
        for (let var k = 0; k < n; ++k) {
            real_parts.write_f32(k, real_parts.read_f32(k) / n);
            imag_parts.write_f32(k, imag_parts.read_f32(k) / n);
        }
    }
}

fun main() {
    let N = 1024; // Number of complex samples
    let sample_rate = 1000.0; // Hz
    let frequency = 50.0; // Hz (for sine wave)

    // Create input data (real values only for now)
    let real_parts = ByteArray.with_size(N * 4); // N float32 values, each 4 bytes
    let imag_parts = ByteArray.with_size(N * 4); // N float32 values, each 4 bytes
    let PI = 3.141592653589793;

    for (let var i = 0; i < N; ++i) {
        // Generate a sine wave
        let value = (2.0 * PI * frequency * (i / sample_rate)).sin();
        real_parts.write_f32(i, value);
        imag_parts.write_f32(i, 0.0);
    }

    // --- Benchmark FFT ---
    let start_time = $time_current_ms();
    fft(real_parts, imag_parts, false); // Compute forward FFT
    let end_time = $time_current_ms();
    let fft_time = end_time - start_time;

    $println("FFT of " + N.to_s() + " samples took: " + fft_time.to_s() + " ms");

    // Optional: Print first few FFT results (magnitude)
    $println("First 20 FFT magnitudes:");
    for (let var i = 0; i < 20; ++i) {
        let re = real_parts.read_f32(i);
        let im = imag_parts.read_f32(i);
        let magnitude = (re * re + im * im).sqrt();
        $println("  " + i.to_s() + ": " + magnitude.format_decimals(4));
    }

    // --- Benchmark Inverse FFT ---
    // Re-initialize input for IFFT if you want to test it independently
    // For now, we'll just run IFFT on the result of the forward FFT
    let start_time_ifft = $time_current_ms();
    fft(real_parts, imag_parts, true); // Compute inverse FFT
    let end_time_ifft = $time_current_ms();
    let ifft_time = end_time_ifft - start_time_ifft;

    $println("Inverse FFT of " + N.to_s() + " samples took: " + ifft_time.to_s() + " ms");

    // Optional: Print first few IFFT results (real part)
    $println("First 20 IFFT real parts:");
    for (let var i = 0; i < 20; ++i) {
        $println("  " + i.to_f().to_s() + ": " + real_parts.read_f32(i).format_decimals(4));
    }
}

main();