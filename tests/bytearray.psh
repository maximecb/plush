// Test ByteArray manipulation functions with direct byte access

// Test with_size
let b1 = ByteArray.with_size(16);
assert(b1.len == 16);

// Test fill_u32
let bs = ByteArray.with_size(8);
bs.fill_u32(0, 2, 0xDEADBEEF);
assert(bs[0] == 0xEF);
assert(bs[1] == 0xBE);
assert(bs[2] == 0xAD);
assert(bs[3] == 0xDE);
assert(bs[4] == 0xEF);
assert(bs[5] == 0xBE);
assert(bs[6] == 0xAD);
assert(bs[7] == 0xDE);

// Test set_u32
// Values are always written with a little-endian ordering
let b2 = ByteArray.with_size(4);
b2.set_u32(0, 0x12345678);
assert(b2[0] == 0x78);
assert(b2[1] == 0x56);
assert(b2[2] == 0x34);
assert(b2[3] == 0x12);

// Test store_u16
// Values are always written with a little-endian ordering
let b2a = ByteArray.with_size(2);
b2a.store_u16(0, 0x3344);
assert(b2a[0] == 0x44);
assert(b2a[1] == 0x33);

// Test set_f32
let b3 = ByteArray.with_size(4);
b3.set_f32(0, 0.625);
assert(b3.get_f32(0) == 0.625);
assert(b3.num_f32() == 1);

// Test zero_fill
let b4 = ByteArray.with_size(4);
b4.fill_u32(0, 1, 0xFFFFFFFF);
b4.zero_fill();
assert(b4[0] == 0);
assert(b4[1] == 0);
assert(b4[2] == 0);
assert(b4[3] == 0);

// Test memcpy
let b5_src = ByteArray.with_size(4);
b5_src.set_u32(0, 0xCAFEBABE);

let b5_dst = ByteArray.with_size(4);
b5_dst.memcpy(0, b5_src, 0, 4);
assert(b5_dst[0] == 0xBE);
assert(b5_dst[1] == 0xBA);
assert(b5_dst[2] == 0xFE);
assert(b5_dst[3] == 0xCA);

// Test resize
let b6 = ByteArray.with_size(10);
assert(b6.len == 10);

// Resize to a larger size
b6.resize(20);
assert(b6.len == 20);

// Check that the new elements are zero
for (let var i = 10; i < 20; ++i) {
    assert(b6[i] == 0);
}

// Resize to a smaller size
b6.resize(5);
assert(b6.len == 5);

// Aligned vs unaligned f32 access
{
    let ba = ByteArray.with_size(8);
    ba.set_f32(1, 0.625);
    assert(ba.get_f32(1) == 0.625);
    assert(ba.load_f32(4) == 0.625);
}

$println("ByteArray tests passed!");
